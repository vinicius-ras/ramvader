/*
 * Copyright (C) 2014 Vinicius Rogério Araujo Silva
 *
 * This file is part of RAMvader.
 *
 * RAMvader is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * RAMvader is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with RAMvader.  If not, see <http://www.gnu.org/licenses/>.
 */

using RAMvader.Attributes;
using RAMvader.Utilities;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Text;

namespace RAMvader.CodeInjection
{
    /// <summary>
    ///    Implements the logic behind the injection of code caves and variables into a target process' memory space.
    /// </summary>
    /// <typeparam name="TMemoryAlterationSetID">
    ///    An enumerated type which specifies the identifiers for Memory Alteration Sets
    ///    that can be enabled or disabled into the target process' memory space.
    /// </typeparam>
    /// <typeparam name="TCodeCave">An enumerated type which specifies the identifiers for code caves.</typeparam>
    /// <typeparam name="TVariable">
    ///    An enumerated type which specifies the identifiers for variables to be injected at the
    ///    target process.
    /// </typeparam>
    public partial class Injector<TMemoryAlterationSetID, TCodeCave, TVariable> : NotifyPropertyChangedAdapter
	{
		#region PRIVATE FIELDS
		/// <summary>
		///    The object used to attach to the target process, so that the <see cref="Injector{TMemoryAlterationSetID, TCodeCave, TVariable}"/> can
		///    perform I/O operations into the target process' memory.
		/// </summary>
		private Target m_targetProcess;
		/// <summary>Keeps the base address of the memory which was allocated for the target process.</summary>
		private IntPtr m_baseInjectionAddress = IntPtr.Zero;
		/// <summary>
		///    Keeps track of how many bytes have been generated by the <see cref="Injector{TMemoryAlterationSetID, TCodeCave, TVariable}"/>
		///    during an injection procedure.
		/// </summary>
		private int m_currentInjectionOffset = 0;
		/// <summary>Backs the <see cref="IsInjected"/> property.</summary>
		private bool m_isInjected = false;
		/// <summary>
		///    A flag specifying if the <see cref="Injector{TMemoryAlterationSetID, TCodeCave, TVariable}"/> has allocated memory in the target process for
		///    injecting its data. When the <see cref="Injector{TMemoryAlterationSetID, TCodeCave, TVariable}"/> allocates memory in the target process, it is
		///    responsible for freing it whenever necessary.
		/// </summary>
		private bool m_bHasAllocatedMemory = false;
		/// <summary>The sequence of bytes which separate two consecutive code caves.</summary>
		private byte [] m_codeCavesSeparator =
		{
			X86Constants.OPCODE_NOP, X86Constants.OPCODE_NOP, X86Constants.OPCODE_NOP, X86Constants.OPCODE_NOP,
			X86Constants.OPCODE_NOP, X86Constants.OPCODE_NOP, X86Constants.OPCODE_NOP, X86Constants.OPCODE_NOP,
		};
		/// <summary>The sequence of bytes which separate the code caves region from the variables region.</summary>
		private byte [] m_variablesSectionSeparator =
		{
            X86Constants.OPCODE_INT3, X86Constants.OPCODE_INT3, X86Constants.OPCODE_INT3, X86Constants.OPCODE_INT3,
            X86Constants.OPCODE_INT3, X86Constants.OPCODE_INT3, X86Constants.OPCODE_INT3, X86Constants.OPCODE_INT3,
		};
		/// <summary>Keeps all the alterations registered for a given memory alteration set.</summary>
		private Dictionary<TMemoryAlterationSetID, List<MemoryAlterationBase>> m_memoryAlterationSets = new Dictionary<TMemoryAlterationSetID, List<MemoryAlterationBase>>();
		/// <summary>
		///    Indexer field used to access the code cave offsets, usually for WPF Binding purposes.
		///    Calls <see cref="Injector{TMemoryAlterationSetID, TCodeCave, TVariable}.GetCodeCaveOffset(TCodeCave)"/> internally.
		/// </summary>
		private NestedPropertyIndexerCodeCaveOffset m_codeCaveOffset;
		/// <summary>
		///    Indexer property used to access the address where a code cave has been injected, usually
		///    for WPF Binding purposes. Calls <see cref="Injector{TMemoryAlterationSetID, TCodeCave, TVariable}.GetInjectedCodeCaveAddress(TCodeCave)"/> internally.
		/// </summary>
		private NestedPropertyIndexerInjectedCodeCaveAddress m_injectedCodeCaveAddress;
		/// <summary>
		///    Indexer property used to access variable offsets, usually for WPF Binding purposes.
		///    Calls <see cref="Injector{TMemoryAlterationSetID, TCodeCave, TVariable}.GetVariableOffset(TVariable)"/> internally.
		/// </summary>
		private NestedPropertyIndexerVariableOffset m_variableOffset;
		/// <summary>
		///    Indexer property used to access the address where a variable has been injected, usually
		///    for WPF Binding purposes. Calls <see cref="Injector{TMemoryAlterationSetID, TCodeCave, TVariable}.GetInjectedVariableAddress(TVariable)"/> internally.
		/// </summary>
		private NestedPropertyIndexerInjectedVariableAddress m_injectedVariableAddress;
		/// <summary>
		///    Indexer property used to retrieve the size of a variable, usually for WPF Binding purposes.
		///    Calls <see cref="Injector{TMemoryAlterationSetID, TCodeCave, TVariable}.GetVariableSize(TVariable)"/> internally.
		/// </summary>
		private NestedPropertyIndexerVariableSize m_variableSize;
		/// <summary>
		///    Maps each code cave identifier (<typeparamref name="TCodeCave"/>) to
		///    the object that holds its definition (<see cref="CodeCaveDefinition{TMemoryAlterationSetID, TCodeCave, TVariable}"/>).
		/// </summary>
		private Dictionary<TCodeCave, CodeCaveDefinition<TMemoryAlterationSetID,TCodeCave,TVariable>> m_codeCaveDefinitions = new Dictionary<TCodeCave, CodeCaveDefinition<TMemoryAlterationSetID,TCodeCave,TVariable>>();
		/// <summary>
		///    Maps each injection variable identifier (<typeparamref name="TVariable"/>) to
		///    the object that holds its definition (<see cref="VariableDefinition"/>).
		/// </summary>
		private Dictionary<TVariable, VariableDefinition> m_variableDefinitions = new Dictionary<TVariable, VariableDefinition>();
		#endregion





		#region PUBLIC PROPERTIES
		/// <summary>
		///    Keeps the base address of the memory which was allocated for the target process.
		///    Backed by the <see cref="m_baseInjectionAddress"/> field.
		/// </summary>
		public IntPtr BaseInjectionAddress
		{
			get { return m_baseInjectionAddress; }
			private set
			{
				m_baseInjectionAddress = value;
				SendPropertyChangedNotification();

				// The following properties also need to send a "property changed"
				// notification when the Base Injection Address changes
				// IMPORTANT: Their backing fields' values are NOT altered to "null" by this operation!
				// These properties' setter methods do not alter the underlying value, they only fire
				// "property changed" notifications for WPF Bindings to work correctly..
				InjectedCodeCaveAddress = null;
				InjectedVariableAddress = null;
			}
		}
		/// <summary>
		///    A flag that is set to true whenever the <see cref="Inject()"/> (or <see cref="Inject(MemoryAddress)"/>) method is called and succeeds, and set to false
		///    whenever the<see cref="ResetAllocatedMemoryData"/> gets called.
		/// </summary>
		public bool IsInjected
		{
			get { return m_isInjected; }
			private set
			{
				m_isInjected = value;
				SendPropertyChangedNotification();
			}
		}
		/// <summary>
		///    The object used to attach to the target process, so that the <see cref="Injector{TMemoryAlterationSetID, TCodeCave, TVariable}"/> can
		///    perform I/O operations into the target process' memory.
		///    Backed by the <see cref="m_targetProcess"/> field.
		/// </summary>
		public Target TargetProcess
		{
			get { return m_targetProcess; }
			private set
			{
				m_targetProcess = value;
				SendPropertyChangedNotification();
			}
		}
		/// <summary>
		///    The total number of required bytes to inject the code caves and variables into the target
		///    process' memory space, as calculated by a call to the method <see cref="CalculateRequiredBytesCount"/>.
		/// </summary>
		public int RequiredBytesCount
		{
			get { return CalculateRequiredBytesCount(); }
			private set
			{
				// Simulates property updating for the Binding system to work properly
				SendPropertyChangedNotification();
			}
		}
		/// <summary>
		///    Indexer property used to access the code cave offsets, usually for WPF Binding purposes.
		///    Calls <see cref="Injector{TMemoryAlterationSetID, TCodeCave, TVariable}.GetCodeCaveOffset(TCodeCave)"/> internally.
		///    Backed by the <see cref="m_codeCaveOffset"/> field.
		/// </summary>
		public NestedPropertyIndexerCodeCaveOffset CodeCaveOffset
		{
			get { return m_codeCaveOffset; }
			private set { SendPropertyChangedNotification(); }
		}
		/// <summary>
		///    Indexer property used to access the address where a code cave has been injected, usually
		///    for WPF Binding purposes. Calls <see cref="Injector{TMemoryAlterationSetID, TCodeCave, TVariable}.GetInjectedCodeCaveAddress(TCodeCave)"/> internally.
		///    Backed by the <see cref="m_injectedCodeCaveAddress"/> field.
		/// </summary>
		public NestedPropertyIndexerInjectedCodeCaveAddress InjectedCodeCaveAddress
		{
			get { return m_injectedCodeCaveAddress; }
			private set { SendPropertyChangedNotification(); }
		}
		/// <summary>
		///    Indexer property used to access variable offsets, usually for WPF Binding purposes.
		///    Calls <see cref="Injector{TMemoryAlterationSetID, TCodeCave, TVariable}.GetVariableOffset(TVariable)"/> internally.
		///    Backed by the <see cref="m_variableOffset"/> field.
		/// </summary>
		public NestedPropertyIndexerVariableOffset VariableOffset
		{
			get { return m_variableOffset; }
			private set { SendPropertyChangedNotification(); }
		}
		/// <summary>
		///    Indexer property used to access the address where a variable has been injected, usually for WPF Binding purposes.
		///    Calls <see cref="Injector{TMemoryAlterationSetID, TCodeCave, TVariable}.GetInjectedVariableAddress(TVariable)"/> internally.
		///    Backed by the <see cref="m_injectedVariableAddress"/> field.
		/// </summary>
		public NestedPropertyIndexerInjectedVariableAddress InjectedVariableAddress
		{
			get { return m_injectedVariableAddress; }
			private set { SendPropertyChangedNotification(); }
		}
		/// <summary>
		///    Indexer property used to retrieve the size of a variable, usually for WPF Binding purposes.
		///    Calls <see cref="Injector{TMemoryAlterationSetID, TCodeCave, TVariable}.GetVariableSize(TVariable)"/> internally.
		///    Backed by the <see cref="m_variableSize"/> field.
		/// </summary>
		public NestedPropertyIndexerVariableSize VariableSize
		{
			get { return m_variableSize; }
			private set { SendPropertyChangedNotification(); }
		}
		#endregion





        #region PUBLIC STATIC METHODS
        /// <summary>
        ///    Utility method for retrieving a sequence of bytes which represent the machine-level opcode corresponding
        ///    to a x86 branch instruction, such as CALL, JMP, or a JCC ("conditional jump") instruction.
        /// </summary>
        /// <param name="instructionType">The specific type of branch instruction to be generated.</param>
        /// <param name="branchInstructionAddress">The address where the branch instruction is supposed to be placed in the target process' memory space.</param>
        /// <param name="targetInstructionAddress">The address to where the placed branch instruction will make the target process' execution flow to.</param>
        /// <param name="instructionSize">
        ///    When replacing an instruction in a target process' memory space by a branch instruction, this parameter specifies the
        ///    size of the instruction to be replaced. If this size is larger than the size of the branch instruction, the remaining bytes
        ///    are filled with NOP opcodes in the returned bytes sequence, so that the branch instruction might replace other instructions
        ///    while keeping the consistency of its surrounding instructions when the flow of code returns from the branch (if that ever
        ///    happens).
        ///
        ///    If the size does not matter, <see cref="X86Constants.INSTRUCTION_SIZE_ANY"/> can be used.
        /// </param>
        /// <returns>Returns a sequence of bytes representing the branch instruction's opcode(s) that compose the given instruction.</returns>
        /// <exception cref="UnsupportedInstructionGenerationException">Thrown when the instruction cannot be generated, because the given instruction type does not exist or has not been implemented.</exception>
        /// <exception cref="IllegalInstructionGenerationException">Thrown when the instruction cannot be generated, because the generated instruction would be illegal somehow.</exception>
        /// <exception cref="InstructionTooLargeException">Thrown when the given instruction size is less than the size required to generate the instruction.</exception>
        public static byte[] GetX86BranchInstructionBytes(EX86BranchInstructionType instructionType, MemoryAddress branchInstructionAddress, MemoryAddress targetInstructionAddress, int instructionSize = X86Constants.INSTRUCTION_SIZE_ANY)
        {
            // Verify total number of bytes required for generating the instruction, the offset limits they should obey to, and if this is a SHORT or NEAR branch
            var instructionMetadata = instructionType.GetAttribute<X86BranchInstructionMetadata>();

            bool isShortBranch;
            if (instructionMetadata.OffsetType == typeof(SByte))
                isShortBranch = true;
            else if (instructionMetadata.OffsetType == typeof(Int32))
                isShortBranch = false;
            else
                throw new UnsupportedInstructionGenerationException(
                    $"[{typeof(Injector<TMemoryAlterationSetID, TCodeCave, TVariable>).ExpandedName()}] Failed to retrieve branch instruction bytes: instruction of type \"{nameof(EX86BranchInstructionType)}.{instructionType.ToString()}\" is" +
                    $" currently unsupported.");

            string propertyNameMinValue = nameof(Decimal.MinValue),
                propertyNameMaxValue = nameof(Decimal.MaxValue);
            object minDatatypeValue = instructionMetadata.OffsetType.GetField(propertyNameMinValue).GetValue(null),
                maxDatatypeValue = instructionMetadata.OffsetType.GetField(propertyNameMaxValue).GetValue(null);
            Int64 minRelativeOffset = Convert.ToInt64(minDatatypeValue),
                maxRelativeOffset = Convert.ToInt64(maxDatatypeValue);

            // Check if the instruction being generated has enough space to actually be generated
            int totalRequiredBytes = instructionMetadata.TotalInstructionSize;
            if ( instructionSize != X86Constants.INSTRUCTION_SIZE_ANY && totalRequiredBytes > instructionSize )
                throw new InstructionTooLargeException(instructionSize, totalRequiredBytes);

            // Calculate the relative offset between the instruction AFTER the branch instruction (as per required in all relative-branching x86 instruction) and its target point.
            // Then, check if the offset is valid for generating the instruction.
            Int64 nextInstructionAddress = branchInstructionAddress.Address.ToInt64() + totalRequiredBytes;
            Int64 relativeOffset = targetInstructionAddress.Address.ToInt64() - nextInstructionAddress;

            if (relativeOffset < minRelativeOffset || relativeOffset > maxRelativeOffset)
                throw new IllegalInstructionGenerationException(
                    $"[{typeof(Injector<TMemoryAlterationSetID, TCodeCave, TVariable>).ExpandedName()}] Failed to retrieve branch instruction bytes: instruction of type \"{nameof(EX86BranchInstructionType)}.{instructionType.ToString()}\" cannot" +
                    $" be generated for an instruction which is {relativeOffset} bytes away from the branching instruction's address (limits must be in the range [{minRelativeOffset}, {maxRelativeOffset}]).");

            byte[] relativeOffsetBytes;
            if (isShortBranch) {
                // Int64 needs to be converted to a signed byte and then to a byte (converting Int64 to a byte directly would fire an overflow exception)
                sbyte signedByteOffset = Convert.ToSByte(relativeOffset);
                byte unsignedByteOffset = (byte)signedByteOffset;

                relativeOffsetBytes = new byte[1] { unsignedByteOffset };
            }
            else
            {
                Int32 relativeOffset32 = Convert.ToInt32(relativeOffset);

                // NOTICE: x86 is a little-endian architecture, so we're forcing that endianness here
                relativeOffsetBytes = Target.GetValueAsBytesArray(relativeOffset32, EEndianness.evEndiannessLittle);
            }

            // Copy the bytes to the result and return it
            byte[] result = new byte[totalRequiredBytes],
                mainOpcodeBytes = instructionMetadata.MainOpcodeBytes;

            Array.Copy(mainOpcodeBytes, result, mainOpcodeBytes.Length);
            Array.Copy(relativeOffsetBytes, 0, result, mainOpcodeBytes.Length, relativeOffsetBytes.Length);

            return result;
        }
        #endregion





        #region PUBLIC METHODS
        /// <summary>
        ///    Constructor. The constructor of the <see cref="Injector{TMemoryAlterationSetID, TCodeCave, TVariable}"/> class checks the code caves and
        ///    variables for consistency, throwing an exception if there is any error found.
        /// </summary>
        /// <exception cref="UnsupportedDataTypeException">
        ///    Thrown if any of the injection variables (enumerators of the type <typeparamref name="TVariable"/>) has
        ///    a data type that is not supported by the RAMvader library.
        /// </exception>
        /// <exception cref="InjectorGenericParametersException">
        ///    Thrown in cases where there are any errors with the generic types defined for the <see cref="Injector{TMemoryAlterationSetID, TCodeCave, TVariable}"/>.
        ///    The types <typeparamref name="TMemoryAlterationSetID"/>, <typeparamref name="TCodeCave"/> and <typeparamref name="TVariable"/> MUST be enumerations.
        /// </exception>
        public Injector()
		{
			// Check the template parameters used to create the Injector instance: both must represent enumeration types.
			if ( typeof( TMemoryAlterationSetID ).IsEnum == false )
				throw new InjectorGenericParametersException($"[{typeof(Injector<TMemoryAlterationSetID, TCodeCave, TVariable>).ExpandedName()}] Failed to create instance. The type defined for memory alteration set identifiers was \"{typeof( TMemoryAlterationSetID ).Name}\", while it MUST be an enumerated type!");

			if ( typeof( TCodeCave ).IsEnum == false )
				throw new InjectorGenericParametersException($"[{typeof(Injector<TMemoryAlterationSetID, TCodeCave, TVariable>).ExpandedName()}] Failed to create instance. The type defined for code cave identifiers was \"{typeof( TCodeCave ).Name}\", while it MUST be an enumerated type!");

			if ( typeof( TVariable ).IsEnum == false )
				throw new InjectorGenericParametersException($"[{typeof(Injector<TMemoryAlterationSetID, TCodeCave, TVariable>).ExpandedName()}] Failed to create instance. The type defined for variable identifiers was \"{typeof( TVariable ).Name}\", while it MUST be an enumerated type!");

			// Initialize indexers.
			// IMPORTANT: That is the ONLY point where indexers are initialized. Their respective properties'
			// setter methods will NEVER alter their instance references - their only purpose is to raise
			// "property changed" notifications for the WPF Binding system whenever necessary
			m_codeCaveOffset = new NestedPropertyIndexerCodeCaveOffset( this );
			m_injectedCodeCaveAddress = new NestedPropertyIndexerInjectedCodeCaveAddress( this );
			m_variableOffset = new NestedPropertyIndexerVariableOffset( this );
			m_injectedVariableAddress = new NestedPropertyIndexerInjectedVariableAddress( this );
			m_variableSize = new NestedPropertyIndexerVariableSize( this );
		}


		/// <summary>
		///    Initializes or modifies the reference to the object used by the <see cref="Injector{TMemoryAlterationSetID, TCodeCave, TVariable}"/>
		///    to perform write operations to the target process' memory. The <see cref="Injector{TMemoryAlterationSetID, TCodeCave, TVariable}"/>
		///    also uses this object to know the endianness and pointer size of the target process.
		/// </summary>
		/// <param name="targetProc">The object used for performing memory I/O operations on the target process.</param>
		/// <seealso cref="GetTargetProcess"/>
		public void SetTargetProcess( Target targetProc )
		{
			TargetProcess = targetProc;
		}


		/// <summary>
		///    Retrieves the current reference to the object used by the <see cref="Injector{TMemoryAlterationSetID, TCodeCave, TVariable}"/> to
		///    perform write operations to the target process' memory.
		///    The <see cref="Injector{TMemoryAlterationSetID, TCodeCave, TVariable}"/> also uses this object to know the endianness and pointer
		///    size of the target process.
		/// </summary>
		/// <returns>Returns the object used for performing memory I/O operations on the target process.</returns>
		/// <seealso cref="SetTargetProcess(Target)"/>
		public Target GetTargetProcess()
		{
			return TargetProcess;
		}


		/// <summary>Modifies the sequence of bytes used to separate two consecutive code caves.</summary>
		/// <param name="byteSeq">The new sequence of bytes to use as a separator. This can be an empty array, but should not be null.</param>
		public void SetCodeCavesSeparationBytes( params byte[] byteSeq )
		{
			m_codeCavesSeparator = byteSeq;
		}


		/// <summary>Retrieves the sequence of bytes used to separate two consecutive code caves.</summary>
		/// <returns>Returns the sequence of bytes used to separate two consecutive code caves in memory.</returns>
		public byte[] GetCodeCavesSeparationBytes()
		{
			return m_codeCavesSeparator;
		}


		/// <summary>Modifies the sequence of bytes used to separate the injected code caves section from the injected variables section.</summary>
		/// <param name="byteSeq">The new sequence of bytes to use as a separator. This can be an empty array, but should not be null.</param>
		public void SetVariablesSectionSeparationBytes( params byte[] byteSeq )
		{
			m_variablesSectionSeparator = byteSeq;
		}


		/// <summary>Retrieves the sequence of bytes used to separate the injected code caves section from the injected variables section.</summary>
		/// <returns>Returns the sequence of bytes used to separate two consecutive code caves in memory.</returns>
		public byte[] GetVariablesSectionSeparationBytes()
		{
			return m_variablesSectionSeparator;
		}


		/// <summary>Retrieves the address where the <see cref="Injector{TMemoryAlterationSetID, TCodeCave, TVariable}"/> has injected its data on the target process.</summary>
		/// <returns>
		///    Returns the base address where the injection has been performed.
		///    If the <see cref="Injector{TMemoryAlterationSetID, TCodeCave, TVariable}"/> didn't perform the injection yet, the return value is IntPtr.Zero.
		/// </returns>
		/// <seealso cref="Inject()"/>
		/// <seealso cref="Inject(MemoryAddress)"/>
		public IntPtr GetBaseInjectionAddress()
		{
			return BaseInjectionAddress;
		}


		/// <summary>Retrieves the offset of a given code cave, relative to the base injection address into the target process' memory space.</summary>
		/// <param name="codeCaveID">The identifier of the code cave.</param>
		/// <returns>Returns the offset of the given code cave.</returns>
		/// <exception cref="InjectionArtifactNotFoundException">Thrown when the artifact (injection variable or code cave) could not be found by the method.</exception>
		public int GetCodeCaveOffset( TCodeCave codeCaveID )
		{
			int offset = 0;
			var codeCaves = (TCodeCave[]) Enum.GetValues( typeof( TCodeCave ) );

			Target targetRef = this.TargetProcess;
			for ( int c = 0; c < codeCaves.Length; c++ )
			{
				// Ignore code caves that are not defined (they're considered "size zero")
				var codeCaveSpecs = this.GetCodeCaveDefinition( codeCaves[c] );
				if ( codeCaveSpecs == null )
					continue;

				// Has the target code cave been found?
				if ( codeCaves[c].Equals( codeCaveID ) )
					return offset;

				// Retrieve the size of the code cave, in bytes, through its
				// specification attribute. Add the code cave's size and the
				// code cave separation bytes count to calculate the next code cave's
				// offset.
				offset += codeCaveSpecs.GetCodeCaveSize( targetRef );
				offset += m_codeCavesSeparator.Length;
			}

			throw new InjectionArtifactNotFoundException($"[{typeof(Injector<TMemoryAlterationSetID, TCodeCave, TVariable>).ExpandedName()}] Cannot retrieve offset for code cave identified by \"{codeCaveID.ToString()}\"!");
		}


		/// <summary>
		///    Retrieves the address of an injected code cave.
		///    This method should only be called after a base injection address has been defined for the <see cref="Injector{TMemoryAlterationSetID, TCodeCave, TVariable}"/>
		///    to Inject code caves and variables.
		/// </summary>
		/// <param name="codeCaveID">The identifier of the target code cave.</param>
		/// <returns>Returns the address of the given code cave, into the target process' memory space.</returns>
		/// <exception cref="InjectionArtifactNotFoundException">Thrown when the artifact (injection variable or code cave) could not be found by the method.</exception>
		public AbsoluteMemoryAddress GetInjectedCodeCaveAddress( TCodeCave codeCaveID )
		{
			if ( this.IsInjected == false )
				throw new InjectionArtifactNotFoundException($"[{typeof(Injector<TMemoryAlterationSetID, TCodeCave, TVariable>).ExpandedName()}] Cannot retrieve injected code cave's address (\"{codeCaveID.ToString()}\"): the {typeof(Injector<TMemoryAlterationSetID, TCodeCave, TVariable>).ExpandedName()} has not allocated memory into the target process yet!");

			return new AbsoluteMemoryAddress( BaseInjectionAddress + GetCodeCaveOffset( codeCaveID ) );
		}


		/// <summary>Retrieves the address of an injected code cave, represented as bytes stored in the target process' memory space.</summary>
		/// <param name="codeCaveID">The identifier of the target code cave.</param>
		/// <returns>
		///    Returns the array of bytes representing the address of the injected code cave, as it is to be stored into the target process'
		///    memory space.
		/// </returns>
		/// <exception cref="NullReferenceException">
		///    Thrown when the <see cref="Target"/> associated with the <see cref="Injector{TMemoryAlterationSetID, TCodeCave, TVariable}"/> hasn't been set.
		///    A <see cref="Target"/> instance can be associated to an <see cref="Injector{TMemoryAlterationSetID, TCodeCave, TVariable}"/> by calling
		///    the method <see cref="Injector{TMemoryAlterationSetID, TCodeCave, TVariable}.SetTargetProcess(Target)"/>.
		/// </exception>
		public byte[] GetInjectedCodeCaveAddressAsBytes( TCodeCave codeCaveID )
		{
			// The target process HAS to be specified, because it is the only one who knows the target process'
			// pointers size and endianness
			if ( TargetProcess == null )
				throw new NullReferenceException($"Cannot retrieve the address (bytes-form) of a injected code cave: the {typeof(Injector<TMemoryAlterationSetID, TCodeCave, TVariable>).ExpandedName()} object has not been initialized with a {typeof( Target ).Name}!");

			// Retrive the address (in the target process' memory space) of the injected code cave and then use
			// the RAMvaderTarget object to retrieve its byte-representation into the target process' memory space
			IntPtr caveAddress = this.GetInjectedCodeCaveAddress( codeCaveID ).Address;
			return TargetProcess.GetValueAsBytesArrayInTargetProcess( caveAddress );
		}


		/// <summary>
		///    Verifies if a given code cave has been injected by the <see cref="Injector{TMemoryAlterationSetID, TCodeCave, TVariable}"/> on
		///    the target process' memory space.
		/// </summary>
		/// <param name="caveID">The code cave whose injection needs to be verified.</param>
		/// <returns>
		///    If the <see cref="Injector{TMemoryAlterationSetID, TCodeCave, TVariable}"/> hasn't performed the injection procedure yet, or if
		///    its associated <see cref="TargetProcess"/> object isn't attached, this method returns <code>false</code>.
		///    Else, this method returns a flag specifying if the code cave has been injected. This method returns false for all code caves without
		///    a definition, as undefined injection artifacts are never injected.
		/// </returns>
		/// <exception cref="NullReferenceException">Thrown when the <see cref="TargetProcess"/> hasn't been set for this <see cref="Injector{TMemoryAlterationSetID, TCodeCave, TVariable}"/>.</exception>
		public bool IsCodeCaveInjected( TCodeCave caveID )
		{
			// Verify if the injector has an associated target process
			if ( TargetProcess == null )
				throw new NullReferenceException($"The {typeof(Injector<TMemoryAlterationSetID, TCodeCave, TVariable>).ExpandedName()} instance is not associated to a {typeof( Target ).Name} object!");

			// Verify if the target process is attached, and if the injection has been performed already
			if ( TargetProcess.Attached == false || this.IsInjected == false )
				return false;

			// Try to retrieve the code cave's injection address. If an InjectionArtifactException is thrown, this means the artifact is NOT injected.
			try
			{
				this.GetInjectedCodeCaveAddress( caveID );
			}
			catch ( InjectionArtifactNotFoundException )
			{
				return false;
			}
			return true;
		}


		/// <summary>Retrieves the offset of a given variable, relative to the base injection address into the target process' memory space.</summary>
		/// <param name="varID">The identifier of the variable whose offset is to be retrieved.</param>
		/// <returns>Returns the offset to given variable.</returns>
		/// <exception cref="InjectionArtifactNotFoundException">Thrown when the artifact (injection variable or code cave) could not be found by the method.</exception>
		public int GetVariableOffset( TVariable varID )
		{
			Target targetRef = this.TargetProcess;

			// Get the offset for the injected variables region in memory...
			var codeCaves = (TCodeCave[]) Enum.GetValues( typeof( TCodeCave ) );
			int lastDefinedCodeCaveIndex = codeCaves.Length - 1;
			int lastDefinedCodeCaveOffset = 0, lastDefinedCodeCaveSize = 0;
			if ( codeCaves.Length > 0 )
			{
				// Find the index of the last defined code cave
				CodeCaveDefinition<TMemoryAlterationSetID,TCodeCave,TVariable> lastDefinedCodeCaveSpecs = null;
				while ( lastDefinedCodeCaveIndex >= 0 )
				{
					lastDefinedCodeCaveSpecs = this.GetCodeCaveDefinition( codeCaves[lastDefinedCodeCaveIndex] );
					if ( lastDefinedCodeCaveSpecs != null )
						break;

					lastDefinedCodeCaveIndex--;
				}

				// If the found index is valid, use it to check the offset and size of the last code cave
				if ( lastDefinedCodeCaveIndex >= 0 )
				{
					lastDefinedCodeCaveOffset = GetCodeCaveOffset( codeCaves[lastDefinedCodeCaveIndex] );
					lastDefinedCodeCaveSize = lastDefinedCodeCaveSpecs.GetCodeCaveSize( targetRef );
				}
			}

			int varOffset = lastDefinedCodeCaveOffset + lastDefinedCodeCaveSize;
			if ( lastDefinedCodeCaveIndex > 0 )
				varOffset += m_variablesSectionSeparator.Length;

			// Calculate the given variable's offset inside the injection variables' region
			foreach ( TVariable curVar in Enum.GetValues( typeof( TVariable ) ) )
			{
				// Ignore variables which haven't been defined
				VariableDefinition varSpecs = this.GetVariableDefinition( curVar );
				if ( varSpecs == null )
					continue;

				// Has the variable been found?
				if ( curVar.Equals( varID ) )
					return varOffset;

				// Move to the next variable
				varOffset += this.GetVariableSize( curVar );
			}

			throw new InjectionArtifactNotFoundException($"[{typeof(Injector<TMemoryAlterationSetID, TCodeCave, TVariable>).ExpandedName()}] Cannot retrieve offset for variable identified by \"{varID.ToString()}\"!");
		}


		/// <summary>
		///    Retrieves the address of an injected variable.
		///    This method should only be called after a base injection address has been defined for
		///    the <see cref="Injector{TMemoryAlterationSetID, TCodeCave, TVariable}"/> to Inject code caves and variables.
		/// </summary>
		/// <param name="varID">The identifier of the target variable.</param>
		/// <returns>Returns the address of the given variable, into the target process' memory space.</returns>
		/// <exception cref="InjectionArtifactNotFoundException">Thrown when the artifact (injection variable or code cave) could not be found by the method.</exception>
		public AbsoluteMemoryAddress GetInjectedVariableAddress( TVariable varID )
		{
			if ( this.IsInjected == false )
				throw new InjectionArtifactNotFoundException( $"[{typeof(Injector<TMemoryAlterationSetID, TCodeCave, TVariable>).ExpandedName()}] Cannot retrieve injected variable's address (\"{varID.ToString()}\"): the {typeof(Injector<TMemoryAlterationSetID, TCodeCave, TVariable>).ExpandedName()} has not allocated memory into the target process yet!");
			return new AbsoluteMemoryAddress( BaseInjectionAddress + GetVariableOffset( varID ) );
		}


		/// <summary>Retrieves the address of an injected variable, represented as bytes stored in the target process' memory space.</summary>
		/// <param name="varID">The identifier of the target variable.</param>
		/// <returns>
		///    Returns the array of bytes representing the address of the injected variable, as it is to be stored into the target process'
		///    memory space.
		/// </returns>
		/// <exception cref="NullReferenceException">
		///    Thrown when the <see cref="Target"/> associated with the <see cref="Injector{TMemoryAlterationSetID, TCodeCave, TVariable}"/> hasn't been set.
		///    A <see cref="Target"/> instance can be associated to an <see cref="Injector{TMemoryAlterationSetID, TCodeCave, TVariable}"/> by calling
		///    the method <see cref="Injector{TMemoryAlterationSetID, TCodeCave, TVariable}.SetTargetProcess(Target)"/>.
		/// </exception>
		public byte[] GetInjectedVariableAddressAsBytes( TVariable varID )
		{
			// The target process HAS to be specified, because it is the only one who knows the target process'
			// pointers size and endianness
			if ( TargetProcess == null )
				throw new NullReferenceException($"Cannot retrieve the address (bytes-form) of a injected variable: the {typeof(Injector<TMemoryAlterationSetID, TCodeCave, TVariable>).ExpandedName()} object has not been initialized with a {typeof( Target ).Name}!");

			// Retrive the address (in the target process' memory space) of the injected variable and then use
			// the RAMvaderTarget object to retrieve its byte-representation into the target process' memory space
			IntPtr varAddress = this.GetInjectedVariableAddress( varID ).Address;
			return TargetProcess.GetValueAsBytesArrayInTargetProcess( varAddress );
		}


		/// <summary>
		///    Verifies if a given variable has been injected by the <see cref="Injector{TMemoryAlterationSetID, TCodeCave, TVariable}"/> on
		///    the target process' memory space.
		/// </summary>
		/// <param name="varID">The variable whose injection needs to be verified.</param>
		/// <returns>
		///    If the <see cref="Injector{TMemoryAlterationSetID, TCodeCave, TVariable}"/> hasn't performed the injection procedure yet, or if
		///    its associated <see cref="TargetProcess"/> object isn't attached, this method returns <code>false</code>.
		///    Else, this method returns a flag specifying if the variable has been injected. This method returns false for all variables without
		///    a definition, as undefined injection artifacts are never injected.
		/// </returns>
		/// <exception cref="NullReferenceException">Thrown when the <see cref="TargetProcess"/> hasn't been set for this <see cref="Injector{TMemoryAlterationSetID, TCodeCave, TVariable}"/>.</exception>
		public bool IsVariableInjected( TVariable varID )
		{
			// Verify if the injector has an associated target process
			if ( TargetProcess == null )
				throw new NullReferenceException($"The {typeof(Injector<TMemoryAlterationSetID, TCodeCave, TVariable>).ExpandedName()} instance is not associated to a {typeof( Target ).Name} object!");

			// Verify if the target process is attached, and if the injection has been performed already
			if ( TargetProcess.Attached == false || this.IsInjected == false )
				return false;

			// Try to retrieve the variable's injection address. If an InjectionArtifactException is thrown, this means the artifact is NOT injected.
			try
			{
				this.GetInjectedVariableAddress( varID );
			}
			catch ( InjectionArtifactNotFoundException )
			{
				return false;
			}
			return true;
		}


		/// <summary>Retrieves the size of a given injection variable.</summary>
		/// <param name="varID">The identifier of the variable whose size is to be retrieved.</param>
		/// <returns>
		///    Returns the size of the given injection variable, given in bytes.
		///    If the variable has no definition set for it, the returned size is ZERO.
		/// </returns>
		/// <exception cref="NullReferenceException">
		///    Thrown when the <see cref="Target"/> associated with the <see cref="Injector{TMemoryAlterationSetID, TCodeCave, TVariable}"/> hasn't been set.
		///    A <see cref="Target"/> instance can be associated to an <see cref="Injector{TMemoryAlterationSetID, TCodeCave, TVariable}"/> by calling
		///    the method <see cref="Injector{TMemoryAlterationSetID, TCodeCave, TVariable}.SetTargetProcess(Target)"/>.
		/// </exception>
		public int GetVariableSize( TVariable varID )
		{
			// Retrieve the type of the injection variable
			VariableDefinition injVarMetadata = this.GetVariableDefinition(varID);
			if ( injVarMetadata == null )
				return 0;
			Type varType = injVarMetadata.InitialValue.GetType();

			// Pointer types have special processing, because the target process might use either 32-bit or 64-bit pointers
			if ( varType == typeof( IntPtr ) )
			{
				// Pointer types need the target process to be initialized
				if ( TargetProcess == null )
					throw new NullReferenceException($"The {typeof(Injector<TMemoryAlterationSetID, TCodeCave, TVariable>).ExpandedName()} class cannot retrieve the size of an injection variable of type IntPtr before its target process is initialized!");

				return this.TargetProcess.GetActualTargetPointerSizeInBytes();
			}
			return Target.GetSupportedDataTypeSizeInBytes( varType );
		}


		/// <summary>
		///    Calculates the total number of required bytes to inject the code caves and variables into the target process' memory space.
		///    This calculation takes in consideration the separation bytes between two consecutive code caves, the separation between the
		///    code caves section and the variables section and the size of each one of the injection variables.
		/// </summary>
		/// <returns>Returns the number of bytes required to Inject into the target process' memory.</returns>
		public int CalculateRequiredBytesCount()
		{
			int totalRequiredBytes = 0;
			Target targetRef = this.TargetProcess;

			// Calculate space required for all code caves
			var allCodeCaves = (TCodeCave[]) Enum.GetValues( typeof( TCodeCave ) );
			int totalDefinedCodeCaves = 0;
			foreach ( TCodeCave curCodeCave in allCodeCaves )
			{
				var curCodeCaveSpecs = this.GetCodeCaveDefinition( curCodeCave );
				if ( curCodeCaveSpecs == null )
					continue;

				totalDefinedCodeCaves++;
				totalRequiredBytes += curCodeCaveSpecs.GetCodeCaveSize( targetRef );
			}

			// Calculate space required for variables
			var allVariables = (TVariable[]) Enum.GetValues( typeof( TVariable ) );
			bool hasDefinedVariables = false;
			foreach ( TVariable curVariable in allVariables )
			{
				// Retrieve the definition of the variable, and do not process non-defined variables
				VariableDefinition varSpecs = this.GetVariableDefinition( curVariable );
				if ( varSpecs == null )
					continue;

				// Count the variable's bytes
				hasDefinedVariables = true;
				totalRequiredBytes += this.GetVariableSize( curVariable );
			}

			// Calculate space required between (consecutive) code caves
			if ( totalDefinedCodeCaves > 0 )
				totalRequiredBytes += ( totalDefinedCodeCaves - 1 ) * m_codeCavesSeparator.Length;

			// Calculate space required between the code caves section and the
			// variables section (only if there are both code caves and variables defined)
			if ( totalDefinedCodeCaves > 0 && hasDefinedVariables )
				totalRequiredBytes += m_variablesSectionSeparator.Length;

			return totalRequiredBytes;
		}


		/// <summary>
		///    Adds a memory alteration to the set of alterations related to a given identifier.
		///    Memory alteration sets are kept in as list, and this method adds a memory alteration to the end of this list.
		///    The elements of a set of memory alterations are enabled/disabled in the order they get added to the list.
		///    You can then call <see cref="SetMemoryAlterationsActive(TMemoryAlterationSetID, bool)"/> to enable or disable the whole set of alterations related to an identifier.
		/// </summary>
		/// <param name="memoryAlterationSetID">The identifier that identifies the set of alterations that can be enabled/disabled all at once.</param>
		/// <param name="memoryAlteration">An object representing the memory alteration that should be added to the given set.</param>
		public void AddMemoryAlteration( TMemoryAlterationSetID memoryAlterationSetID, MemoryAlterationBase memoryAlteration )
		{
			// Retrieve the list used to keep the given memory alterations set, creating it when necessary
			if ( m_memoryAlterationSets.ContainsKey( memoryAlterationSetID ) == false )
				m_memoryAlterationSets[memoryAlterationSetID] = new List<MemoryAlterationBase>();

			List<MemoryAlterationBase> memoryAlterationSet = m_memoryAlterationSets[memoryAlterationSetID];

			// Add alteration to the list
			memoryAlterationSet.Add( memoryAlteration );
		}


		/// <summary>
		///    Removes a memory alteration from the set of alterations related to a given identifier.
		///    Memory alteration sets are kept in as list, and this method removes a memory alteration from this list.
		///    The elements of a set of memory alterations are enabled/disabled in the order they get added to the list.
		///    You can then call <see cref="SetMemoryAlterationsActive(TMemoryAlterationSetID, bool)"/> to enable or disable the whole set of alterations related to an identifier.
		/// </summary>
		/// <param name="memoryAlterationSetID">The identifier that identifies the set of alterations that can be enabled/disabled all at once.</param>
		/// <param name="memoryAlteration">The memory alteration to be removed from the given set.</param>
		/// <returns>Returns a flag specifying if the alteration has been removed from the set.</returns>
		public bool RemoveMemoryAlteration( TMemoryAlterationSetID memoryAlterationSetID, MemoryAlterationBase memoryAlteration )
		{
			// Retrieve the list used to keep the given memory alterations set, creating it when necessary
			if ( m_memoryAlterationSets.ContainsKey( memoryAlterationSetID ) == false )
				return false;

			List<MemoryAlterationBase> memoryAlterationSet = m_memoryAlterationSets[memoryAlterationSetID];

			// Remove item form the list, removing the list if it gets empty
			bool result = memoryAlterationSet.Remove( memoryAlteration );
			if ( memoryAlterationSet.Count <= 0 )
				m_memoryAlterationSets.Remove( memoryAlterationSetID );
			return result;
		}


		/// <summary>Returns an enumerable object containing all memory alterations registered for a given memory alteration set.</summary>
		/// <param name="memoryAlterationSetID">The identifier that identifies the set of alterations that can be enabled/disabled all at once.</param>
		/// <returns>Returns an enumerable list containing all the memory alterations in the given set.</returns>
		public IEnumerable<MemoryAlterationBase> GetMemoryAlterations( TMemoryAlterationSetID memoryAlterationSetID )
		{
			if ( m_memoryAlterationSets.ContainsKey( memoryAlterationSetID ) == false )
				return new List<MemoryAlterationBase>(0);   // return an empty list
			return m_memoryAlterationSets[memoryAlterationSetID];
		}


		/// <summary>Activates or deactivates all the memory alterations registered for a given memory alterations set.</summary>
		/// <param name="memoryAlterationSetID">The identifier that identifies the set of alterations that can be enabled/disabled all at once.</param>
		/// <param name="bActivate">A flag specifying if the alterations should be activated or deactivated.</param>
		/// <returns>
		///    Returns a flag specifying if all alterations have been activated.
		///    If any of the memory alterations in a set fail to be activated/deactivated, the returned value is false.
		/// </returns>
		public bool SetMemoryAlterationsActive( TMemoryAlterationSetID memoryAlterationSetID, bool bActivate )
		{
			// If there is no alteration set with the given identifier, return true right away (nothing else to do)
			if ( m_memoryAlterationSets.ContainsKey( memoryAlterationSetID ) == false )
				return true;

			// Activate or deactivate alterations
			bool activationResult = true;
			foreach ( MemoryAlterationBase curMemoryAlteration in m_memoryAlterationSets[memoryAlterationSetID] )
			{
				if ( curMemoryAlteration.SetEnabled( this, bActivate ) == false )
					activationResult = false;
			}

			return activationResult;
		}


		/// <summary>Activates or deactivates all the memory alterations registered with the <see cref="Injector{TMemoryAlterationSetID, TCodeCave, TVariable}"/>.</summary>
		/// <param name="bActivate">A flag specifying if the alterations should be activated or deactivated.</param>
		/// <returns>
		///    Returns a flag specifying if all alterations have been activated.
		///    If any of the memory alterations in a set fail to be activated/deactivated, the returned value is false.
		/// </returns>
		public bool SetAllMemoryAlterationsActive( bool bActivate )
		{
			bool result = true;
			foreach ( TMemoryAlterationSetID curMemAlterationSet in Enum.GetValues( typeof( TMemoryAlterationSetID ) ) )
			{
				if ( this.SetMemoryAlterationsActive( curMemAlterationSet, bActivate ) == false )
					result = false;
			}

			return result;
		}


		/// <summary>
		///    Instantiates a <see cref="CodeCaveBuilder{TMemoryAlterationSetID, TCodeCave, TVariable}"/> to allow
		///    for the creation of a new code cave that can be used with this <see cref="Injector{TMemoryAlterationSetID, TCodeCave, TVariable}"/>.
		/// </summary>
		/// <returns>Returns a builder that can be used to create a new code cave for this <see cref="Injector{TMemoryAlterationSetID, TCodeCave, TVariable}"/>.</returns>
		public CodeCaveBuilder<TMemoryAlterationSetID,TCodeCave,TVariable> NewCodeCave()
		{
			return new CodeCaveBuilder<TMemoryAlterationSetID, TCodeCave, TVariable>( this );
		}


		/// <summary>
		///    Allocates memory into the target process' memory space and injects the code caves and
		///    variables into that allocated memory.
		/// </summary>
		/// <exception cref="NullReferenceException">
		///    Thrown when the <see cref="Target"/> associated with the <see cref="Injector{TMemoryAlterationSetID, TCodeCave, TVariable}"/> hasn't been set.
		///    A <see cref="Target"/> instance can be associated to an <see cref="Injector{TMemoryAlterationSetID, TCodeCave, TVariable}"/> by calling
		///    the method <see cref="Injector{TMemoryAlterationSetID, TCodeCave, TVariable}.SetTargetProcess(Target)"/>.
		/// </exception>
		/// <exception cref="InstanceNotAttachedException">
		///    Thrown when the <see cref="Target"/> instance has not been attached to a target
		///    process before the method is called.
		/// </exception>
		/// <exception cref="VirtualMemoryAllocationException">
		///    Thrown when the method cannot allocate virtual memory in the target process' memory space, to inject the data in the target process.
		///    Some softwares might implement security schemes that prevent you from allocating virtual memory on them, which in turn might require you
		///    to use manual injection of data (see <see cref="Inject(MemoryAddress)"/>).
		/// </exception>
		/// <seealso cref="GetBaseInjectionAddress"/>
		public void Inject()
		{
			// The target process should've been already defined and attached
			if ( TargetProcess == null )
				throw new NullReferenceException($"No target process ({typeof( Target ).Name} instance) has been set for the {this.GetType().Name}.");

			if ( TargetProcess.IsAttached() == false )
				throw new InstanceNotAttachedException();

			// Allocate READ+WRITE+EXECUTE memory into the target process' memory space
			uint totalRequiredSpace = (uint) CalculateRequiredBytesCount();
			IntPtr baseInjectionAddress = IntPtr.Zero;
			if ( totalRequiredSpace != 0 )
			{
				Process targetProcessRef = TargetProcess.GetAttachedProcess();
				baseInjectionAddress = WinAPI.VirtualAllocEx(
					targetProcessRef.Handle, IntPtr.Zero, totalRequiredSpace,
					WinAPI.AllocationType.Reserve | WinAPI.AllocationType.Commit,
					WinAPI.MemoryProtection.ExecuteReadWrite );
				if ( baseInjectionAddress == IntPtr.Zero )
					throw new VirtualMemoryAllocationException();

				// Now the Injector is responsible for deallocating the allocated memory
				m_bHasAllocatedMemory = true;
			}

			// Continue with the rest of the injection procedures
			try
			{
				this.Inject( new AbsoluteMemoryAddress( baseInjectionAddress ) );
			}
			catch ( InjectorException )
			{
				// Reset the Injector's data and throw the exception up
				this.ResetAllocatedMemoryData();
				throw;
			}
		}


		/// <summary>
		///    <para>
		///       Injects the code caves and variables into the target process' memory space.
		///       This overloaded version of the <see cref="Inject()"/> method can be used to Inject the code caves into a specific point of the
		///       target process' memory space. Notice, though, that for the code caves to work correctly, they need to be injected
		///       into a memory region with appropriate permissions. Those are usually READ+WRITE+EXECUTE permissions (READ+WRITE
		///       for injected variables and EXECUTE for allowing the target process to execute the code caves). If you need to
		///       calculate the total number of bytes required by the <see cref="Injector{TMemoryAlterationSetID, TCodeCave, TVariable}"/> to inject
		///       the code caves and variables, see <see cref="CalculateRequiredBytesCount"/>.
		///    </para>
		///    <para>
		///       Notice that you should not use the <see cref="InjectedCodeCaveMemoryAddress{TMemoryAlterationSetID, TCodeCave, TVariable}"/> and <see cref="InjectedVariableMemoryAddress{TMemoryAlterationSetID, TCodeCave, TVariable}"/> classes
		///       to specify the injection point for this method, because for these classes to solve the right base address, they would require a
		///       previous injection to have happened already.
		///    </para>
		/// </summary>
		/// <param name="baseInjectionAddress">
		///    The address - into the target process' memory space - where the <see cref="Injector{TMemoryAlterationSetID, TCodeCave, TVariable}"/>
		///    will Inject the code caves and variables.
		///    A value of "IntPtr.Zero" will cause the method to exit without any effect on the target process' memory space.
		/// </param>
		/// <exception cref="NullReferenceException">
		///    Thrown when the <see cref="Target"/> associated with the <see cref="Injector{TMemoryAlterationSetID, TCodeCave, TVariable}"/> hasn't been set.
		///    A <see cref="Target"/> instance can be associated to an <see cref="Injector{TMemoryAlterationSetID, TCodeCave, TVariable}"/> by calling
		///    the method <see cref="Injector{TMemoryAlterationSetID, TCodeCave, TVariable}.SetTargetProcess(Target)"/>.
		/// </exception>
		/// <exception cref="InstanceNotAttachedException">
		///    Thrown when the <see cref="Target"/> instance has not been attached to a target
		///    process before the method is called.
		/// </exception>
		/// <exception cref="RequiredWriteException">
		///    Thrown when the <see cref="Injector{TMemoryAlterationSetID, TCodeCave, TVariable}"/> fails to write the injection
		///    data in the target process' memory space.
		/// </exception>
		/// <seealso cref="GetBaseInjectionAddress"/>
		public void Inject( MemoryAddress baseInjectionAddress )
		{
			// The target process should've been already defined and attached
			Target targetRef = this.TargetProcess;
			if ( targetRef == null )
				throw new NullReferenceException($"No target process ({typeof( Target ).Name} instance) has been set for the {this.GetType().Name}.");

			if ( TargetProcess.IsAttached() == false )
				throw new InstanceNotAttachedException();

			// Cannot inject anything into another process' memory space if something has already been injected.
			if ( this.IsInjected )
				throw new InstanceAlreadyInjectedException();

			BaseInjectionAddress = baseInjectionAddress.Address;
			IsInjected = true;

			// Generate the bytes which constitute the data to be injected
			int totalRequiredBytes = this.CalculateRequiredBytesCount();
			List<byte> bytesToInject = new List<byte>( totalRequiredBytes );

			// Get the bytes which represent the code caves section
			bool bFirstCaveAlreadyInjected = false;
			foreach ( TCodeCave curCodeCave in Enum.GetValues( typeof( TCodeCave ) ) )
			{
				// Try to retrieve the specifications of the code cave
				var caveSpecs = this.GetCodeCaveDefinition( curCodeCave );
				if ( caveSpecs == null )
					continue;

				// Add separators between two consecutive code caves
				if ( bFirstCaveAlreadyInjected )
				{
					bytesToInject.AddRange( m_codeCavesSeparator );
					m_currentInjectionOffset += m_codeCavesSeparator.Length;
				}
				bFirstCaveAlreadyInjected = true;

				// Add the bytes which represent the code cave
				byte [] generatedCodeCaveBytes = caveSpecs.GenerateCodeCaveBytes( this );
				bytesToInject.AddRange( generatedCodeCaveBytes );
			}

			// Add variables
			bool bFirstVariableAlreadyInjected = false;
			foreach ( TVariable curVarID in Enum.GetValues( typeof( TVariable ) ) )
			{
				// Retrieve the definition o the current variable, if any (skipping undefined variables)
				VariableDefinition varSpecs = this.GetVariableDefinition( curVarID );
				if ( varSpecs == null )
					continue;

				// Add separator from the variables section (only if one or more code caves have already been injected)
				if ( bFirstCaveAlreadyInjected &&
					bFirstVariableAlreadyInjected == false )
				{
					bytesToInject.AddRange( m_variablesSectionSeparator );
					m_currentInjectionOffset += m_variablesSectionSeparator.Length;
				}

				bFirstVariableAlreadyInjected = true;

				// Inject variable's initial value
				byte [] varInitialValueAsBytes = TargetProcess.GetValueAsBytesArrayInTargetProcess( varSpecs.InitialValue );

				bytesToInject.AddRange( varInitialValueAsBytes );
				m_currentInjectionOffset += varInitialValueAsBytes.Length;
			}

			// Inject the data!
			if ( TargetProcess.WriteToTarget( baseInjectionAddress, bytesToInject.ToArray() ) == false )
				throw new RequiredWriteException( "Failed to write injection data in the target process' memory space!" );
        }


        /// <summary>
        ///    Called during the injection procedure to retrieve the number of bytes already generated by
        ///    the <see cref="Injector{TMemoryAlterationSetID, TCodeCave, TVariable}"/> instance.
        ///    This method is called by lower APIs which need to use the current injection position, mainly to generate
        ///    branching instructions (which need to know their exact address when they need to be generated).
        /// </summary>
        /// <returns>
        ///    <para>
        ///       Returns the number of bytes that have already been generated by
        ///       the <see cref="Injector{TMemoryAlterationSetID, TCodeCave, TVariable}"/> during an injection
        ///       procedure.
        ///    </para>
        ///    <para>
        ///       If the injection procedure hasn't started yet, or the <see cref="Injector{TMemoryAlterationSetID, TCodeCave, TVariable}"/>
        ///       finds itself in "not injected" state, the return value is zero.
        ///    </para>
        ///    <para>
        ///       If this method is called after a successful injection procedure, the return value is the total number of
        ///       injected bytes (which is effectivelly the same result of calling <see cref="CalculateRequiredBytesCount"/>).
        ///    </para>
        ///    <para>
        ///       If this method is called during the injection procedure (which is usually done when
        ///       processing <see cref="CodeCaveArtifact{TMemoryAlterationSetID, TCodeCave, TVariable}"/> objects that compose
        ///       the code caves to be injected), the return value is the total number of bytes that have been injected so far by
        ///       the <see cref="Injector{TMemoryAlterationSetID, TCodeCave, TVariable}"/>.
        ///    </para>
        /// </returns>
        /// <seealso cref="GetCurrentInjectionAddress"/>
        public int GetCurrentInjectionOffset()
        {
            return m_currentInjectionOffset;
        }


        /// <summary>
        ///    Called during the injection procedure to increase the number of bytes already generated by
        ///    the <see cref="Injector{TMemoryAlterationSetID, TCodeCave, TVariable}"/> instance.
        ///    This method is called by lower APIs to inform changes which should be made in the current injection position,
        ///    mainly to allow for the generation branching instructions (which need to know their exact address when they
        ///    need to be generated).
        /// </summary>
        /// <seealso cref="GetCurrentInjectionOffset"/>
        /// <seealso cref="GetCurrentInjectionAddress"/>
        public void IncreaseCurrentInjectionOffset(int increase)
        {
            m_currentInjectionOffset += increase;
        }


        /// <summary>
        ///    <para>
        ///       Called during the injection procedure to retrieve the address right after the last byte generated by
        ///       the <see cref="Injector{TMemoryAlterationSetID, TCodeCave, TVariable}"/> instance.
        ///       This method is called by lower APIs which need to use the current injection position, mainly to generate
        ///       branching instructions.
        ///    </para>
        ///    <para>
        ///       The return value of this method is effectivelly the sum of <see cref="BaseInjectionAddress"/> with the
        ///       return value of the <see cref="GetCurrentInjectionOffset"/> method.
        ///    </para>
        /// </summary>
        /// <returns>
        ///       The return value of this method is effectivelly the sum of <see cref="BaseInjectionAddress"/> with the
        ///       return value of the <see cref="GetCurrentInjectionOffset"/> method.
        /// </returns>
        /// <seealso cref="GetCurrentInjectionAddress"/>
        public IntPtr GetCurrentInjectionAddress()
		{
			return this.BaseInjectionAddress + this.GetCurrentInjectionOffset();
		}


		/// <summary>
		///    Resets the internal data of the <see cref="Injector{TMemoryAlterationSetID, TCodeCave, TVariable}"/> regarding the memory region where it has injected its data.
		///    This method should be called whenever the target process is terminated or whenever the <see cref="Injector{TMemoryAlterationSetID, TCodeCave, TVariable}"/> object
		///    needs to deallocate the memory it has allocated on the target process.
		/// </summary>
		public void ResetAllocatedMemoryData()
		{
			// If the Injector has allocated memory on the target process, and if the target process
			// is still running, free that allocated memory
			if ( TargetProcess != null )
			{
				Process attachedProcess = TargetProcess.GetAttachedProcess();
				if ( IsInjected && m_bHasAllocatedMemory && attachedProcess != null && attachedProcess.HasExited == false )
				{
					WinAPI.VirtualFreeEx( attachedProcess.Handle, BaseInjectionAddress, 0,
						WinAPI.FreeType.Release );
				}
			}

			// Return allocation address to zero
			BaseInjectionAddress = IntPtr.Zero;
			m_bHasAllocatedMemory = false;
			IsInjected = false;
			m_currentInjectionOffset = 0;
		}


        /// <summary>
        ///    Writes a x86 branch instruction at a specific point of the target process' memory space to enable the process' execution flow
        ///    to be branched to another specific address.
        /// </summary>
        /// <param name="instructionType">The specific type of branch instruction to be generated.</param>
        /// <param name="branchPoint">The address of the target process' memory space where the branch instruction will be written.</param>
        /// <param name="targetAddress">The address to where the target process' execution should be diverted.</param>
        /// <param name="instructionSize">
        ///    The size of the instruction that is going to be replaced by the branch instruction.
        ///    This is used to fill the remaining bytes of the instruction with NOP opcodes, so that when the execution flows back from
        ///    the branch instruction (if it ever does), nothing unexpected happens.
        ///
        ///    If the size does not matter, <see cref="X86Constants.INSTRUCTION_SIZE_ANY"/> can be used.
        /// </param>
        /// <returns>Returns a flag indicating the success of the operation.</returns>
        /// <exception cref="NullReferenceException">
        ///    Thrown when the <see cref="Target"/> associated with the <see cref="Injector{TMemoryAlterationSetID, TCodeCave, TVariable}"/> hasn't been set.
        ///    A <see cref="Target"/> instance can be associated to an <see cref="Injector{TMemoryAlterationSetID, TCodeCave, TVariable}"/> by calling
        ///    the method <see cref="Injector{TMemoryAlterationSetID, TCodeCave, TVariable}.SetTargetProcess(Target)"/>.
        /// </exception>
        /// <exception cref="InstanceNotAttachedException">
        ///    Thrown when the <see cref="Target"/> instance has not been attached to a target
        ///    process before the method is called.
        /// </exception>
        public bool WriteX86BranchInstruction( EX86BranchInstructionType instructionType, MemoryAddress branchPoint, MemoryAddress targetAddress, int instructionSize = X86Constants.INSTRUCTION_SIZE_ANY)
		{
			// Error checking...
			if ( TargetProcess == null )
			{
				throw new NullReferenceException("[{GetInjectorNameWithTemplateParameters()}] Cannot write a x86 branch instruction: target process has not been initialized yet!");
			}

			if ( TargetProcess.IsAttached() == false )
				throw new InstanceNotAttachedException();

			// Build the branch instruction and write it
			byte [] branchInstructionBytes = GetX86BranchInstructionBytes(instructionType, branchPoint, targetAddress, instructionSize);
			return TargetProcess.WriteToTarget( branchPoint, branchInstructionBytes );
		}


		/// <summary>
		///    Updates the value of a given variable into the target process' memory.
		///    This method is safe, as it checks the given variable's metadata against the given value's type to see if it matches
		///    the variable's type before updating the variable's value.
		/// </summary>
		/// <param name="variableID">The identifier of the injected variable whose value is to be updated.</param>
		/// <param name="newValue">The new value for the variable.</param>
		/// <returns>Returns the result of the write operation performed by a call to <see cref="Target.WriteToTarget(MemoryAddress, object)"/>.</returns>
		/// <exception cref="NullReferenceException">
		///    Thrown when the <see cref="Target"/> associated with the <see cref="Injector{TMemoryAlterationSetID, TCodeCave, TVariable}"/> hasn't been set.
		///    A <see cref="Target"/> instance can be associated to an <see cref="Injector{TMemoryAlterationSetID, TCodeCave, TVariable}"/> by calling
		///    the method <see cref="Injector{TMemoryAlterationSetID, TCodeCave, TVariable}.SetTargetProcess(Target)"/>.
		/// </exception>
		/// <exception cref="InstanceNotAttachedException">
		///    Thrown when the <see cref="Target"/> instance has not been attached to a target
		///    process before the method is called.
		/// </exception>
		/// <exception cref="UnmatchedDataTypeException">Thrown when "newValue" does not match the injection variable's type.</exception>
		/// <exception cref="InjectionArtifactNotFoundException">
		///    Thrown when the variable has not been injected in the target process' memory space.
		///    This happens when the variable has no definition (<see cref="VariableDefinition"/>) registered for it with
		///    the <see cref="Injector{TMemoryAlterationSetID, TCodeCave, TVariable}"/>.
		/// </exception>
		public bool WriteVariableValue( TVariable variableID, object newValue )
		{
			// Error checking...
			if ( TargetProcess == null )
				throw new NullReferenceException($"[{typeof(Injector<TMemoryAlterationSetID, TCodeCave, TVariable>).ExpandedName()}] Cannot update variable's value: target process has not been initialized yet!");

			if ( TargetProcess.IsAttached() == false )
				throw new InstanceNotAttachedException();

			VariableDefinition varSpecs = this.GetVariableDefinition( variableID );
			if ( varSpecs == null )
				throw new InjectionArtifactNotFoundException($"[{typeof(Injector<TMemoryAlterationSetID, TCodeCave, TVariable>).ExpandedName()}] Cannot update variable's value: variable identified by \"{variableID.ToString()}\" has no variable definition associated to it!");

			Type injectedVariableType = varSpecs.InitialValue.GetType();
			Type givenValueType = newValue.GetType();
			if ( injectedVariableType != givenValueType )
				throw new UnmatchedDataTypeException( givenValueType, injectedVariableType, (Enum) (Object) variableID );

			// Update the value in the target process' memory space
			return this.TargetProcess.WriteToTarget( new InjectedVariableMemoryAddress<TMemoryAlterationSetID,TCodeCave,TVariable>( this, variableID ), newValue );
		}


		/// <summary>
		///    Reads the current value of a given variable from the target process' memory.
		///    This method is safe, as it checks the given variable's metadata against the given output variable's type to
		///    see if it matches the injected variable's type before reading the output value.
		/// </summary>
		/// <typeparam name="T">The type of the variable to be read, which must match the type of the injected variable.</typeparam>
		/// <param name="variableID">The identifier of the variable whose value is to be read from the target process' memory space.</param>
		/// <param name="outDestiny">
		///    The result of the reading will be stored in this variable.
		///    The referenced variable's data must be of the same type as declared for the variable defined in parameter <code>variableID</code>.
		/// </param>
		/// <returns>Returns the result of the read operation performed by a call to <see cref="Target.ReadFromTarget{T}(MemoryAddress, ref T)"/>.</returns>
		/// <exception cref="NullReferenceException">
		///    Thrown when the <see cref="Target"/> associated with the <see cref="Injector{TMemoryAlterationSetID, TCodeCave, TVariable}"/> hasn't been set.
		///    A <see cref="Target"/> instance can be associated to an <see cref="Injector{TMemoryAlterationSetID, TCodeCave, TVariable}"/> by calling
		///    the method <see cref="Injector{TMemoryAlterationSetID, TCodeCave, TVariable}.SetTargetProcess(Target)"/>.
		/// </exception>
		/// <exception cref="InstanceNotAttachedException">
		///    Thrown when the <see cref="Target"/> instance has not been attached to a target
		///    process before the method is called.
		/// </exception>
		/// <exception cref="InjectionArtifactNotFoundException">
		///    Thrown when the variable has not been injected in the target process' memory space.
		///    This happens when the variable has no definition (<see cref="VariableDefinition"/>) registered for it with
		///    the <see cref="Injector{TMemoryAlterationSetID, TCodeCave, TVariable}"/>.
		/// </exception>
		public bool ReadVariableValue<T>( TVariable variableID, ref T outDestiny )
		{
			// Error checking...
			if ( TargetProcess == null )
				throw new NullReferenceException($"[{typeof(Injector<TMemoryAlterationSetID, TCodeCave, TVariable>).ExpandedName()}] Cannot read injected variable's value: target process has not been initialized yet!");

			if ( TargetProcess.IsAttached() == false )
				throw new InstanceNotAttachedException();

			VariableDefinition varSpecs = this.GetVariableDefinition( variableID );
			if ( varSpecs == null )
				throw new InjectionArtifactNotFoundException($"[{typeof(Injector<TMemoryAlterationSetID, TCodeCave, TVariable>).ExpandedName()}] Cannot update variable's value: variable identified by \"{variableID.ToString()}\" has no variable definition associated to it!");

			Type injectedVariableType = varSpecs.InitialValue.GetType();
			Type outputValueType = typeof(T);
			if ( injectedVariableType != outputValueType )
				throw new UnmatchedDataTypeException( outputValueType, injectedVariableType, (Enum) (Object) variableID );

			// Try to read the value from the target's memory space
			return this.TargetProcess.ReadFromTarget( new InjectedVariableMemoryAddress<TMemoryAlterationSetID,TCodeCave,TVariable>( this, variableID ), ref outDestiny );
		}


		/// <summary>
		///    <para>Updates the definition of a given code cave.</para>
		///    <para>
		///       Currently, the definitions of code caves and injection variables can only
		///       be updated when the <see cref="Injector{TMemoryAlterationSetID, TCodeCave, TVariable}"/> is
		///       in the "not injected" state.
		///    </para>
		/// </summary>
		/// <param name="caveId">The identifier of the code cave whose definition is to be updated.</param>
		/// <param name="definition">An object representing the new definition of the given code cave.</param>
		/// <exception cref="InstanceAlreadyInjectedException">
		///    Thrown when the <see cref="Injector{TMemoryAlterationSetID, TCodeCave, TVariable}"/>'s
		///    instance is already in "injected" state (this method must be called before that
		///    state is entered).
		/// </exception>
		public void SetCodeCaveDefinition( TCodeCave caveId, CodeCaveDefinition<TMemoryAlterationSetID, TCodeCave, TVariable> definition )
		{
			if ( this.IsInjected )
				throw new InstanceAlreadyInjectedException();

			m_codeCaveDefinitions[caveId] = definition;
		}


		/// <summary>
		///    <para>Updates the definition of a given injection variable.</para>
		///    <para>
		///       Currently, the definitions of code caves and injection variables can only
		///       be updated when the <see cref="Injector{TMemoryAlterationSetID, TCodeCave, TVariable}"/> is
		///       in the "not injected" state.
		///    </para>
		/// </summary>
		/// <param name="varId">The identifier of the injection variable whose definition is to be updated.</param>
		/// <param name="definition">An object representing the new definition of the given injection variable.</param>
		/// <exception cref="InstanceAlreadyInjectedException">
		///    Thrown when the <see cref="Injector{TMemoryAlterationSetID, TCodeCave, TVariable}"/>'s
		///    instance is already in "injected" state (this method must be called before that
		///    state is entered).
		/// </exception>
		/// <exception cref="UnsupportedDataTypeException">
		///    Throw when the type of the
		/// </exception>
		public void SetVariableDefinition( TVariable varId, VariableDefinition definition )
		{
			// This method should be called before the instance is injected
			if ( this.IsInjected )
				throw new InstanceAlreadyInjectedException();

			// Verify if the RAMvader library supports the given variable's type
			Type varType = definition.GetInjectionVariableType();
			if ( Target.IsDataTypeSupported( varType ) == false )
				throw new UnsupportedDataTypeException( varType );

			// Update the variable's definition
			m_variableDefinitions[varId] = definition;
		}


		/// <summary>
		///    Retrieves the definition of the given code cave, that has been registered with the
		///    <see cref="Injector{TMemoryAlterationSetID, TCodeCave, TVariable}"/>, if any.
		/// </summary>
		/// <param name="caveId">The identifier of the code cave whose definition is to be retrieved.</param>
		/// <returns>
		///    <para>
		///       In case of success, returns the <see cref="CodeCaveDefinition{TMemoryAlterationSetID, TCodeCave, TVariable}"/> object
		///       representing the definition that has been registered for the given code cave.
		///    </para>
		///    <para>In case of failure, returns <code>null</code>.</para>
		/// </returns>
		public CodeCaveDefinition<TMemoryAlterationSetID, TCodeCave, TVariable> GetCodeCaveDefinition( TCodeCave caveId )
		{
			CodeCaveDefinition<TMemoryAlterationSetID,TCodeCave,TVariable> result = null;
			m_codeCaveDefinitions.TryGetValue( caveId, out result );
			return result;
		}


		/// <summary>
		///    Retrieves the definition of the given injection variable, that has been registered with the
		///    <see cref="Injector{TMemoryAlterationSetID, TCodeCave, TVariable}"/>, if any.
		/// </summary>
		/// <param name="varId">The identifier of the injection variable whose definition is to be retrieved.</param>
		/// <returns>
		///    <para>
		///       In case of success, returns the <see cref="VariableDefinition"/> object
		///       representing the definition that has been registered for the given injection variable.
		///    </para>
		///    <para>In case of failure, returns <code>null</code>.</para>
		/// </returns>
		public VariableDefinition GetVariableDefinition( TVariable varId )
		{
			VariableDefinition result = null;
			m_variableDefinitions.TryGetValue( varId, out result );
			return result;
		}


		/// <summary>
		///    <para>
		///       Clears the definition of a specific code cave, effectively making
		///       it "undefined" for
		///       the <see cref="Injector{TMemoryAlterationSetID, TCodeCave, TVariable}"/>.
		///    </para>
		///    <para>
		///       Calling this will prevent the code cave from being injected in the
		///       target process' memory space - as its definition will be voided - until it gets
		///       redefined/updated.
		///    </para>
		///    <para>
		///       Currently, the definitions of code caves and injection variables can only
		///       be updated when the <see cref="Injector{TMemoryAlterationSetID, TCodeCave, TVariable}"/> is
		///       in the "not injected" state.
		///    </para>
		/// </summary>
		/// <param name="caveId">The code cave whose definition will be cleared.</param>
		/// <returns>Returns a flag specifying if the definition has been found and removed.</returns>
		public bool ClearCodeCaveDefinition( TCodeCave caveId )
		{
			return m_codeCaveDefinitions.Remove( caveId );
		}


		/// <summary>
		///    <para>
		///       Clears the definition of a specific injection variable, effectively making
		///       it "undefined" for
		///       the <see cref="Injector{TMemoryAlterationSetID, TCodeCave, TVariable}"/>.
		///    </para>
		///    <para>
		///       Calling this will prevent the injection variable from being injected in the
		///       target process' memory space - as its definition will be voided - until it gets
		///       redefined/updated.
		///    </para>
		///    <para>
		///       Currently, the definitions of code caves and injection variables can only
		///       be updated when the <see cref="Injector{TMemoryAlterationSetID, TCodeCave, TVariable}"/> is
		///       in the "not injected" state.
		///    </para>
		/// </summary>
		/// <param name="varId">The injection variable whose definition will be cleared.</param>
		/// <returns>Returns a flag specifying if the definition has been found and removed.</returns>
		public bool ClearVariableDefinition( TVariable varId )
		{
			return m_variableDefinitions.Remove( varId );
		}


		/// <summary>
		///    <para>
		///       Clears the definition of all code caves, effectively making
		///       all of them "undefined" for
		///       the <see cref="Injector{TMemoryAlterationSetID, TCodeCave, TVariable}"/>.
		///    </para>
		///    <para>
		///       Calling this will prevent the code caves from being injected in the
		///       target process' memory space - as their definition will be voided - until they get
		///       redefined/updated.
		///    </para>
		///    <para>
		///       Currently, the definitions of code caves and injection variables can only
		///       be updated when the <see cref="Injector{TMemoryAlterationSetID, TCodeCave, TVariable}"/> is
		///       in the "not injected" state.
		///    </para>
		/// </summary>
		public void ClearAllCodeCaveDefinitions()
		{
			m_codeCaveDefinitions.Clear();
		}


		/// <summary>
		///    <para>
		///       Clears the definition of all injection varibles, effectively making
		///       all of them "undefined" for
		///       the <see cref="Injector{TMemoryAlterationSetID, TCodeCave, TVariable}"/>.
		///    </para>
		///    <para>
		///       Calling this will prevent the injection variables from being injected in the
		///       target process' memory space - as their definition will be voided - until they get
		///       redefined/updated.
		///    </para>
		///    <para>
		///       Currently, the definitions of code caves and injection variables can only
		///       be updated when the <see cref="Injector{TMemoryAlterationSetID, TCodeCave, TVariable}"/> is
		///       in the "not injected" state.
		///    </para>
		/// </summary>
		public void ClearAllVariableDefinitions()
		{
			m_variableDefinitions.Clear();
		}
		#endregion
	}
}
