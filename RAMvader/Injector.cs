/*
 * Copyright (C) 2014 Vinicius Rogério Araujo Silva
 *
 * This file is part of RAMvader.
 *
 * RAMvader is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * RAMvader is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with RAMvader.  If not, see <http://www.gnu.org/licenses/>.
 */

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Text;

namespace RAMvader.CodeInjection
{
	/// <summary>
	///    Implements the logic behind the injection of code caves and variables into a target process' memory space.
	/// </summary>
	/// <typeparam name="TMemoryAlterationSetID">
	///    An enumerated type which specifies the identifiers for Memory Alteration Sets
	///    that can be enabled or disabled into the target process' memory space.
	/// </typeparam>
	/// <typeparam name="TCodeCave">An enumerated type which specifies the identifiers for code caves.</typeparam>
	/// <typeparam name="TVariable">
	///    An enumerated type which specifies the identifiers for variables to be injected at the
	///    target process.
	/// </typeparam>
	public partial class Injector<TMemoryAlterationSetID, TCodeCave, TVariable> : NotifyPropertyChangedAdapter
	{
		#region PRIVATE FIELDS
		/// <summary>
		///    The object used to attach to the target process, so that the <see cref="Injector{TMemoryAlterationSetID, TCodeCave, TVariable}"/> can
		///    perform I/O operations into the target process' memory.
		/// </summary>
		private RAMvaderTarget m_targetProcess;
		/// <summary>Keeps the base address of the memory which was allocated for the target process.</summary>
		private IntPtr m_baseInjectionAddress = IntPtr.Zero;
		/// <summary>
		///    Keeps track of how many bytes have been generated by the <see cref="Injector{TMemoryAlterationSetID, TCodeCave, TVariable}"/>
		///    during an injection procedure.
		/// </summary>
		private int m_currentInjectionOffset = 0;
		/// <summary>Backs the <see cref="IsInjected"/> property.</summary>
		private bool m_isInjected = false;
		/// <summary>
		///    A flag specifying if the <see cref="Injector{TMemoryAlterationSetID, TCodeCave, TVariable}"/> has allocated memory in the target process for
		///    injecting its data. When the <see cref="Injector{TMemoryAlterationSetID, TCodeCave, TVariable}"/> allocates memory in the target process, it is
		///    responsible for freing it whenever necessary.
		/// </summary>
		private bool m_bHasAllocatedMemory = false;
		/// <summary>The sequence of bytes which separate two consecutive code caves.</summary>
		private byte [] m_codeCavesSeparator =
		{
			LowLevel.OPCODE_x86_NOP, LowLevel.OPCODE_x86_NOP, LowLevel.OPCODE_x86_NOP, LowLevel.OPCODE_x86_NOP,
			LowLevel.OPCODE_x86_NOP, LowLevel.OPCODE_x86_NOP, LowLevel.OPCODE_x86_NOP, LowLevel.OPCODE_x86_NOP,
		};
		/// <summary>The sequence of bytes which separate the code caves region from the variables region.</summary>
		private byte [] m_variablesSectionSeparator =
		{
			LowLevel.OPCODE_x86_INT3, LowLevel.OPCODE_x86_INT3, LowLevel.OPCODE_x86_INT3, LowLevel.OPCODE_x86_INT3,
		   LowLevel. OPCODE_x86_INT3, LowLevel.OPCODE_x86_INT3, LowLevel.OPCODE_x86_INT3, LowLevel.OPCODE_x86_INT3,
		};
		/// <summary>Keeps all the alterations registered for a given memory alteration set.</summary>
		private Dictionary<TMemoryAlterationSetID, List<MemoryAlterationBase>> m_memoryAlterationSets = new Dictionary<TMemoryAlterationSetID, List<MemoryAlterationBase>>();
		/// <summary>
		///    Indexer field used to access the code cave offsets, usually for WPF Binding purposes.
		///    Calls <see cref="Injector{TMemoryAlterationSetID, TCodeCave, TVariable}.GetCodeCaveOffset(TCodeCave)"/> internally.
		/// </summary>
		private NestedPropertyIndexerCodeCaveOffset m_codeCaveOffset;
		/// <summary>
		///    Indexer property used to access the address where a code cave has been injected, usually
		///    for WPF Binding purposes. Calls <see cref="Injector{TMemoryAlterationSetID, TCodeCave, TVariable}.GetInjectedCodeCaveAddress(TCodeCave)"/> internally.
		/// </summary>
		private NestedPropertyIndexerInjectedCodeCaveAddress m_injectedCodeCaveAddress;
		/// <summary>
		///    Indexer property used to access variable offsets, usually for WPF Binding purposes.
		///    Calls <see cref="Injector{TMemoryAlterationSetID, TCodeCave, TVariable}.GetVariableOffset(TVariable)"/> internally.
		/// </summary>
		private NestedPropertyIndexerVariableOffset m_variableOffset;
		/// <summary>
		///    Indexer property used to access the address where a variable has been injected, usually
		///    for WPF Binding purposes. Calls <see cref="Injector{TMemoryAlterationSetID, TCodeCave, TVariable}.GetInjectedVariableAddress(TVariable)"/> internally.
		/// </summary>
		private NestedPropertyIndexerInjectedVariableAddress m_injectedVariableAddress;
		/// <summary>
		///    Indexer property used to retrieve the size of a variable, usually for WPF Binding purposes.
		///    Calls <see cref="Injector{TMemoryAlterationSetID, TCodeCave, TVariable}.GetVariableSize(TVariable)"/> internally.
		/// </summary>
		private NestedPropertyIndexerVariableSize m_variableSize;
		/// <summary>
		///    Maps each code cave identifier (<typeparamref name="TCodeCave"/>) to
		///    the object that holds its definition (<see cref="CodeCaveDefinition{TMemoryAlterationSetID, TCodeCave, TVariable}"/>).
		/// </summary>
		private Dictionary<TCodeCave, CodeCaveDefinition<TMemoryAlterationSetID,TCodeCave,TVariable>> m_codeCaveDefinitions = new Dictionary<TCodeCave, CodeCaveDefinition<TMemoryAlterationSetID,TCodeCave,TVariable>>();
		/// <summary>
		///    Maps each injection variable identifier (<typeparamref name="TVariable"/>) to
		///    the object that holds its definition (<see cref="VariableDefinition"/>).
		/// </summary>
		private Dictionary<TVariable, VariableDefinition> m_variableDefinitions = new Dictionary<TVariable, VariableDefinition>();
		#endregion





		#region PUBLIC PROPERTIES
		/// <summary>
		///    Keeps the base address of the memory which was allocated for the target process.
		///    Backed by the <see cref="m_baseInjectionAddress"/> field.
		/// </summary>
		public IntPtr BaseInjectionAddress
		{
			get { return m_baseInjectionAddress; }
			private set
			{
				m_baseInjectionAddress = value;
				SendPropertyChangedNotification();

				// The following properties also need to send a "property changed"
				// notification when the Base Injection Address changes
				// IMPORTANT: Their backing fields' values are NOT altered to "null" by this operation!
				// These properties' setter methods do not alter the underlying value, they only fire
				// "property changed" notifications for WPF Bindings to work correctly..
				InjectedCodeCaveAddress = null;
				InjectedVariableAddress = null;
			}
		}
		/// <summary>
		///    A flag that is set to true whenever the <see cref="Inject()"/> (or <see cref="Inject(MemoryAddress)"/>) method is called and succeeds, and set to false
		///    whenever the<see cref="ResetAllocatedMemoryData"/> gets called.
		/// </summary>
		public bool IsInjected
		{
			get { return m_isInjected; }
			private set
			{
				m_isInjected = value;
				SendPropertyChangedNotification();
			}
		}
		/// <summary>
		///    The object used to attach to the target process, so that the <see cref="Injector{TMemoryAlterationSetID, TCodeCave, TVariable}"/> can
		///    perform I/O operations into the target process' memory.
		///    Backed by the <see cref="m_targetProcess"/> field.
		/// </summary>
		public RAMvaderTarget TargetProcess
		{
			get { return m_targetProcess; }
			private set
			{
				m_targetProcess = value;
				SendPropertyChangedNotification();
			}
		}
		/// <summary>
		///    The total number of required bytes to inject the code caves and variables into the target
		///    process' memory space, as calculated by a call to the method <see cref="CalculateRequiredBytesCount"/>.
		/// </summary>
		public int RequiredBytesCount
		{
			get { return CalculateRequiredBytesCount(); }
			private set
			{
				// Simulates property updating for the Binding system to work properly
				SendPropertyChangedNotification();
			}
		}
		/// <summary>
		///    Indexer property used to access the code cave offsets, usually for WPF Binding purposes.
		///    Calls <see cref="Injector{TMemoryAlterationSetID, TCodeCave, TVariable}.GetCodeCaveOffset(TCodeCave)"/> internally.
		///    Backed by the <see cref="m_codeCaveOffset"/> field.
		/// </summary>
		public NestedPropertyIndexerCodeCaveOffset CodeCaveOffset
		{
			get { return m_codeCaveOffset; }
			private set { SendPropertyChangedNotification(); }
		}
		/// <summary>
		///    Indexer property used to access the address where a code cave has been injected, usually
		///    for WPF Binding purposes. Calls <see cref="Injector{TMemoryAlterationSetID, TCodeCave, TVariable}.GetInjectedCodeCaveAddress(TCodeCave)"/> internally.
		///    Backed by the <see cref="m_injectedCodeCaveAddress"/> field.
		/// </summary>
		public NestedPropertyIndexerInjectedCodeCaveAddress InjectedCodeCaveAddress
		{
			get { return m_injectedCodeCaveAddress; }
			private set { SendPropertyChangedNotification(); }
		}
		/// <summary>
		///    Indexer property used to access variable offsets, usually for WPF Binding purposes.
		///    Calls <see cref="Injector{TMemoryAlterationSetID, TCodeCave, TVariable}.GetVariableOffset(TVariable)"/> internally.
		///    Backed by the <see cref="m_variableOffset"/> field.
		/// </summary>
		public NestedPropertyIndexerVariableOffset VariableOffset
		{
			get { return m_variableOffset; }
			private set { SendPropertyChangedNotification(); }
		}
		/// <summary>
		///    Indexer property used to access the address where a variable has been injected, usually for WPF Binding purposes.
		///    Calls <see cref="Injector{TMemoryAlterationSetID, TCodeCave, TVariable}.GetInjectedVariableAddress(TVariable)"/> internally.
		///    Backed by the <see cref="m_injectedVariableAddress"/> field.
		/// </summary>
		public NestedPropertyIndexerInjectedVariableAddress InjectedVariableAddress
		{
			get { return m_injectedVariableAddress; }
			private set { SendPropertyChangedNotification(); }
		}
		/// <summary>
		///    Indexer property used to retrieve the size of a variable, usually for WPF Binding purposes.
		///    Calls <see cref="Injector{TMemoryAlterationSetID, TCodeCave, TVariable}.GetVariableSize(TVariable)"/> internally.
		///    Backed by the <see cref="m_variableSize"/> field.
		/// </summary>
		public NestedPropertyIndexerVariableSize VariableSize
		{
			get { return m_variableSize; }
			private set { SendPropertyChangedNotification(); }
		}
		#endregion





		#region PRIVATE STATIC METHODS
		/// <summary>
		///    Utility method for retrieving a human-readable name for the <see cref="Injector{TMemoryAlterationSetID, TCodeCave, TVariable}"/> class,
		///    including the name of its generic parameters.
		/// </summary>
		/// <returns>Returns a string containing the name of the <see cref="Injector{TMemoryAlterationSetID, TCodeCave, TVariable}"/> class and its generic parameters.</returns>
		private static string GetInjectorNameWithTemplateParameters()
		{
			Type injectorType = typeof( Injector<TMemoryAlterationSetID, TCodeCave, TVariable> );
			Type [] genericArguments = injectorType.GetGenericArguments();
			int totalGenericArguments = genericArguments.Length;

			StringBuilder builder = new StringBuilder( injectorType.Name.Remove( injectorType.Name.IndexOf('`') ) );
			builder.Append( '<' );
			for ( int a = 0; a < totalGenericArguments; a++ )
			{
				if ( a > 0 )
					builder.Append( ", " );
				builder.Append( genericArguments[a].Name );
			}
			builder.Append( '>' );

			return builder.ToString();
		}
		#endregion





		#region PUBLIC STATIC METHODS
		/// <summary>
		///    Utility method for retrieving a sequence of bytes which represent the machine-level opcode corresponding to a 32-bits CALL instruction.
		///    64-bits CALL instructions are currently not supported by the RAMvader library.
		/// </summary>
		/// <param name="callInstructionAddress">The address of the CALL instruction itself.</param>
		/// <param name="targetCallAddress">The address which should be called by the CALL instruction.</param>
		/// <param name="instructionSize">
		///    When replacing an instruction in a target process' memory space by a CALL instruction, this parameter specifies
		///    the size of the instruction to be replaced. If this size is larger than the size of a CALL instruction, the
		///    remaining bytes are filled with NOP opcodes in the returned bytes sequence, so that the CALL instruction might
		///    replace other instructions while keeping the consistency of its surrounding instructions when a RET instruction is used
		///    to return from the CALL.
		/// </param>
		/// <param name="endianness">The endianness to be used for the offset of the CALL opcode.</param>
		/// <param name="pointerSize">The size of pointer to be used for the offset of the CALL opcode.</param>
		/// <param name="diffPointerSizeError">
		///    The policy for handling errors regarding different sizes of pointers between RAMvader process' pointers and the pointers
		///    size defined by the "pointerSize" parameter.
		/// </param>
		/// <returns>Returns a sequence of bytes representing the CALL opcode that composes the given instruction.</returns>
		/// <exception cref="InstructionTooLargeException">Thrown when the given instruction size is less than the size required to generate the instruction.</exception>
		public static byte[] GetX86CallOpcode( MemoryAddress callInstructionAddress, MemoryAddress targetCallAddress,
			int instructionSize = LowLevel.INSTRUCTION_SIZE_x86_CALL,
			EEndianness endianness = EEndianness.evEndiannessDefault,
			EPointerSize pointerSize = EPointerSize.evPointerSizeDefault,
			EDifferentPointerSizeError diffPointerSizeError = EDifferentPointerSizeError.evThrowException )
		{
			// Initialize defaults
			if ( endianness == EEndianness.evEndiannessDefault )
				endianness = BitConverter.IsLittleEndian ? EEndianness.evEndiannessLittle : EEndianness.evEndiannessBig;

			if ( pointerSize == EPointerSize.evPointerSizeDefault )
				pointerSize = RAMvaderTarget.GetRAMvaderPointerSize();

			// Calculate the offset between the CALL instruction and the target address that it should call
			Object callOffset;

			if ( pointerSize == EPointerSize.evPointerSize32 )
				callOffset = (Int32) ( targetCallAddress.Address.ToInt32() - callInstructionAddress.Address.ToInt32() - LowLevel.INSTRUCTION_SIZE_x86_CALL );
			else if ( pointerSize == EPointerSize.evPointerSize64 )
				callOffset = (Int64) ( targetCallAddress.Address.ToInt64() - callInstructionAddress.Address.ToInt64() - LowLevel.INSTRUCTION_SIZE_x86_CALL );
			else
			{
				throw new UnsupportedPointerSizeException( string.Format(
					"[{0}] Failed to retrieve CALL instruction opcode: the specified pointer size is not supported.",
					GetInjectorNameWithTemplateParameters() ) );
			}

			// Build the CALL opcode
			List<byte> tmpBytes = new List<byte>( LowLevel.INSTRUCTION_SIZE_x86_CALL );
			tmpBytes.Add( LowLevel.OPCODE_x86_CALL );

			byte [] callOffsetAsBytes = RAMvaderTarget.GetValueAsBytesArray( callOffset, endianness, pointerSize, diffPointerSizeError );
			tmpBytes.AddRange( callOffsetAsBytes );

			// Fill the remaining bytes of the given instruction size with NOP opcodes
			int extraNOPs = instructionSize - LowLevel.INSTRUCTION_SIZE_x86_CALL;
			if ( extraNOPs < 0 )
				throw new InstructionTooLargeException( instructionSize, LowLevel.INSTRUCTION_SIZE_x86_CALL );

			for ( int n = 0; n < extraNOPs; n++ )
				tmpBytes.Add( LowLevel.OPCODE_x86_NOP );

			// Return the result
			return tmpBytes.ToArray();
		}


		/// <summary>
		///    Utility method for retrieving a sequence of bytes which represent the machine-level opcode corresponding
		///    to a 32-bits NEAR JUMP instruction. 64-bits JUMP instructions are currently not supported by the RAMvader library.
		/// </summary>
		/// <param name="jumpInstructionType">The specific type of jump instruction to be generated.</param>
		/// <param name="jumpInstructionAddress">The address of the JUMP instruction itself.</param>
		/// <param name="targetJumpAddress">The address to which the JUMP instruction should jump.</param>
		/// <param name="instructionSize">
		///    When replacing an instruction in a target process' memory space by a JUMP instruction, this parameter specifies the
		///    size of the instruction to be replaced. If this size is larger than the size of a JUMP instruction, the remaining bytes
		///    are filled with NOP opcodes in the returned bytes sequence, so that the JUMP instruction might replace other instructions
		///    while keeping the consistency of its surrounding instructions when the flow of code returns from the jump (if that ever
		///    happens).
		/// </param>
		/// <param name="pointerSize">The size of pointer to be used for the offset of the JUMP opcode.</param>
		/// <returns>Returns a sequence of bytes representing the JUMP opcode that composes the given instruction.</returns>
		/// <exception cref="IllegalInstructionGenerationException">Thrown when the instruction cannot be generated, because the generated instruction would be illegal.</exception>
		/// <exception cref="InstructionTooLargeException">Thrown when the given instruction size is less than the size required to generate the instruction.</exception>
		public static byte[] GetX86NearJumpOpcode( EJumpInstructionType jumpInstructionType,
			MemoryAddress jumpInstructionAddress, MemoryAddress targetJumpAddress,
			int instructionSize = LowLevel.INSTRUCTION_SIZE_x86_NEAR_JUMP,
			EPointerSize pointerSize = EPointerSize.evPointerSizeDefault )
		{
			// Initialize defaults
			if ( pointerSize == EPointerSize.evPointerSizeDefault )
				pointerSize = RAMvaderTarget.GetRAMvaderPointerSize();

			// Calculate the offset between the JUMP instruction and the target address that it should jump to
			Object jumpOffset;
			bool offsetIsValid = false;

			if ( pointerSize == EPointerSize.evPointerSize32 )
			{
				// Calculate offset as a signed byte value and verify if offset is valid (if it fits into a single, signed byte)
				Int32 numJumpOffset = (Int32) ( targetJumpAddress.Address.ToInt32() - jumpInstructionAddress.Address.ToInt32() - LowLevel.INSTRUCTION_SIZE_x86_NEAR_JUMP );
				offsetIsValid = ( numJumpOffset >= SByte.MinValue && numJumpOffset <= SByte.MaxValue );

				// Convert offset to unsigned byte (if necessary)
				if ( numJumpOffset < 0 )
					numJumpOffset = Byte.MaxValue + 1 + numJumpOffset;
				jumpOffset = numJumpOffset;
			}
			else if ( pointerSize == EPointerSize.evPointerSize64 )
			{
				// Calculate offset as a signed byte value and verify if offset is valid (if it fits into a single, signed byte)
				Int64 numJumpOffset = (Int64) ( targetJumpAddress.Address.ToInt64() - jumpInstructionAddress.Address.ToInt64() - LowLevel.INSTRUCTION_SIZE_x86_NEAR_JUMP );
				offsetIsValid = ( numJumpOffset >= SByte.MinValue && numJumpOffset <= SByte.MaxValue );

				// Convert offset to unsigned byte (if necessary)
				if ( numJumpOffset < 0 )
					numJumpOffset = Byte.MaxValue + 1 + numJumpOffset;
				jumpOffset = numJumpOffset;
			}
			else
			{
				throw new UnsupportedPointerSizeException( string.Format(
					"[{0}] Failed to retrieve NEAR JUMP instruction opcode: the specified pointer size is not supported.",
					GetInjectorNameWithTemplateParameters() ) );
			}

			// NEAR JUMPs can make jumps to instructions up to 0xFF bytes of distance only
			if ( offsetIsValid == false )
				throw new IllegalInstructionGenerationException( string.Format(
					"[{0}] Failed to retrieve NEAR JUMP instruction opcode: offset between the JUMP instruction and its target jump address is too large for making a NEAR JUMP!",
					GetInjectorNameWithTemplateParameters() ) );

			byte byteJumpOffset = Convert.ToByte( jumpOffset );

			// Build the JUMP opcode
			List<byte> tmpBytes = new List<byte>( LowLevel.INSTRUCTION_SIZE_x86_NEAR_JUMP );
			switch ( jumpInstructionType )
			{
				case EJumpInstructionType.evJMP:
					tmpBytes.Add( LowLevel.OPCODE_x86_NEAR_JMP );
					break;
				case EJumpInstructionType.evJA:
					tmpBytes.Add( LowLevel.OPCODE_x86_NEAR_JA );
					break;
				case EJumpInstructionType.evJAE:
					tmpBytes.Add( LowLevel.OPCODE_x86_NEAR_JAE );
					break;
				case EJumpInstructionType.evJB:
					tmpBytes.Add( LowLevel.OPCODE_x86_NEAR_JB );
					break;
				case EJumpInstructionType.evJBE:
					tmpBytes.Add( LowLevel.OPCODE_x86_NEAR_JBE );
					break;
				case EJumpInstructionType.evJG:
					tmpBytes.Add( LowLevel.OPCODE_x86_NEAR_JG );
					break;
				case EJumpInstructionType.evJGE:
					tmpBytes.Add( LowLevel.OPCODE_x86_NEAR_JGE );
					break;
				case EJumpInstructionType.evJL:
					tmpBytes.Add( LowLevel.OPCODE_x86_NEAR_JL );
					break;
				case EJumpInstructionType.evJLE:
					tmpBytes.Add( LowLevel.OPCODE_x86_NEAR_JLE );
					break;
				case EJumpInstructionType.evJE:
					tmpBytes.Add( LowLevel.OPCODE_x86_NEAR_JE );
					break;
				case EJumpInstructionType.evJNE:
					tmpBytes.Add( LowLevel.OPCODE_x86_NEAR_JNE );
					break;
				default:
					throw new UnsupportedInstructionGenerationException( string.Format(
						"[{0}] Failed to retrieve NEAR JUMP instruction opcode: the specified NEAR JUMP instruction type is not supported.",
						GetInjectorNameWithTemplateParameters() ) );
			}

			tmpBytes.Add( byteJumpOffset );

			// Fill the remaining bytes of the given instruction size with NOP opcodes
			int extraNOPs = instructionSize - LowLevel.INSTRUCTION_SIZE_x86_NEAR_JUMP;
			if ( extraNOPs < 0 )
				throw new InstructionTooLargeException( instructionSize, LowLevel.INSTRUCTION_SIZE_x86_NEAR_JUMP );

			for ( int n = 0; n < extraNOPs; n++ )
				tmpBytes.Add( LowLevel.OPCODE_x86_NOP );

			// Return the result
			return tmpBytes.ToArray();
		}


		/// <summary>
		///    Utility method for retrieving a sequence of bytes which represent the machine-level opcode
		///    corresponding to a x86 FAR JUMP instruction. 64-bits JUMP instructions are currently not supported
		///    by the RAMvader library.
		/// </summary>
		/// <param name="jumpInstructionType">The specific type of jump instruction to be generated.</param>
		/// <param name="jumpInstructionAddress">The address of the JUMP instruction itself.</param>
		/// <param name="targetJumpAddress">The address to which the JUMP instruction should jump.</param>
		/// <param name="instructionSize">
		///    When replacing an instruction in a target process' memory space by a JUMP instruction, this parameter specifies
		///    the size of the instruction to be replaced. If this size is larger than the size of a JUMP instruction, the
		///    remaining bytes are filled with NOP opcodes in the returned bytes sequence, so that the JUMP instruction might
		///    replace other instructions while keeping the consistency of its surrounding instructions when the flow of code
		///    returns from the jump (if that ever happens).
		/// </param>
		/// <param name="endianness">The endianness to be used for the offset of the JUMP opcode.</param>
		/// <param name="pointerSize">The size of pointer to be used for the offset of the JUMP opcode.</param>
		/// <param name="diffPointerSizeError">
		///    The policy for handling errors regarding different sizes of pointers between RAMvader process' pointers and the
		///    pointers size defined by the "pointerSize" parameter.
		/// </param>
		/// <returns>Returns a sequence of bytes representing the JUMP opcode that composes the given instruction.</returns>
		/// <exception cref="IllegalInstructionGenerationException">Thrown when the instruction cannot be generated, because the generated instruction would be illegal.</exception>
		/// <exception cref="InstructionTooLargeException">Thrown when the given instruction size is less than the size required to generate the instruction.</exception>
		public static byte[] GetX86FarJumpOpcode( EJumpInstructionType jumpInstructionType,
			MemoryAddress jumpInstructionAddress, MemoryAddress targetJumpAddress,
			int instructionSize = LowLevel.INSTRUCTION_SIZE_x86_FAR_JUMP,
			EEndianness endianness = EEndianness.evEndiannessDefault,
			EPointerSize pointerSize = EPointerSize.evPointerSizeDefault,
			EDifferentPointerSizeError diffPointerSizeError = EDifferentPointerSizeError.evThrowException )
		{
			// Initialize defaults
			if ( endianness == EEndianness.evEndiannessDefault )
				endianness = BitConverter.IsLittleEndian ? EEndianness.evEndiannessLittle : EEndianness.evEndiannessBig;

			if ( pointerSize == EPointerSize.evPointerSizeDefault )
				pointerSize = RAMvaderTarget.GetRAMvaderPointerSize();

			// Get the bytes that compose a FAR JUMP instruction (NOTICE: unconditional x86 jump instructions have different sizes as compared to conditional jumps)
			List<byte> tmpBytes = new List<byte>();
			switch ( jumpInstructionType )
			{
				case EJumpInstructionType.evJMP:
					tmpBytes.AddRange( LowLevel.OPCODE_x86_FAR_JMP );
					break;
				case EJumpInstructionType.evJA:
					tmpBytes.AddRange( LowLevel.OPCODE_x86_FAR_JA );
					break;
				case EJumpInstructionType.evJAE:
					tmpBytes.AddRange( LowLevel.OPCODE_x86_FAR_JAE );
					break;
				case EJumpInstructionType.evJB:
					tmpBytes.AddRange( LowLevel.OPCODE_x86_FAR_JB );
					break;
				case EJumpInstructionType.evJBE:
					tmpBytes.AddRange( LowLevel.OPCODE_x86_FAR_JBE );
					break;
				case EJumpInstructionType.evJG:
					tmpBytes.AddRange( LowLevel.OPCODE_x86_FAR_JG );
					break;
				case EJumpInstructionType.evJGE:
					tmpBytes.AddRange( LowLevel.OPCODE_x86_FAR_JGE );
					break;
				case EJumpInstructionType.evJL:
					tmpBytes.AddRange( LowLevel.OPCODE_x86_FAR_JL );
					break;
				case EJumpInstructionType.evJLE:
					tmpBytes.AddRange( LowLevel.OPCODE_x86_FAR_JLE );
					break;
				case EJumpInstructionType.evJE:
					tmpBytes.AddRange( LowLevel.OPCODE_x86_FAR_JE );
					break;
				case EJumpInstructionType.evJNE:
					tmpBytes.AddRange( LowLevel.OPCODE_x86_FAR_JNE );
					break;
				default:
					throw new UnsupportedInstructionGenerationException( string.Format(
						"[{0}] Failed to retrieve FAR JUMP instruction opcode: the specified FAR JUMP instruction type is not supported.",
						GetInjectorNameWithTemplateParameters() ) );
			}

			// Calculate the offset between the JUMP instruction and the target address that it should call
			Object jumpOffset;
			bool offsetIsValid = false;

			int farJumpBaseInstructionSize = tmpBytes.Count + 4;   // +4 bytes for the 32-bits JUMP OFFSET

			if ( pointerSize == EPointerSize.evPointerSize32 )
			{
				// Calculate offset as a signed byte value. Using 32-bits calculations, the offset is ALWAYS valid.
				jumpOffset = (Int32) ( targetJumpAddress.Address.ToInt32() - jumpInstructionAddress.Address.ToInt32() - farJumpBaseInstructionSize );
				offsetIsValid = true;
			}
			else if ( pointerSize == EPointerSize.evPointerSize64 )
			{
				// Calculate offset and verify if it is valid (if it fits into a single, signed Int32)
				Int64 numJumpOffset = (Int64) ( targetJumpAddress.Address.ToInt64() - jumpInstructionAddress.Address.ToInt64() - farJumpBaseInstructionSize );
				jumpOffset = numJumpOffset;
				offsetIsValid = ( numJumpOffset >= Int32.MinValue && numJumpOffset <= Int32.MaxValue );
			}
			else
			{
				throw new UnsupportedPointerSizeException( string.Format(
					"[{0}] Failed to retrieve FAR JUMP instruction opcode: the specified pointer size is not supported.",
					GetInjectorNameWithTemplateParameters() ) );
			}

			// FAR JUMPs can make jumps to instructions up to 0xFFFFFFFF bytes of distance only
			if ( offsetIsValid == false )
				throw new IllegalInstructionGenerationException( string.Format(
					"[{0}] Failed to retrieve FAR JUMP instruction opcode: offset between the JUMP instruction and its target jump address is too large for making a FAR JUMP!.",
					GetInjectorNameWithTemplateParameters() ) );


			// Build the FAR JUMP opcode
			byte [] jumpOffsetAsBytes = RAMvaderTarget.GetValueAsBytesArray( jumpOffset, endianness, pointerSize, diffPointerSizeError );
			tmpBytes.AddRange( jumpOffsetAsBytes );

			// Fill the remaining bytes of the given instruction size with NOP opcodes
			int extraNOPs = instructionSize - farJumpBaseInstructionSize;
			if ( extraNOPs < 0 )
				throw new InstructionTooLargeException( instructionSize, farJumpBaseInstructionSize );

			for ( int n = 0; n < extraNOPs; n++ )
				tmpBytes.Add( LowLevel.OPCODE_x86_NOP );

			// Return the result
			return tmpBytes.ToArray();
		}
		#endregion





		#region PUBLIC METHODS
		/// <summary>
		///    Constructor. The constructor of the <see cref="Injector{TMemoryAlterationSetID, TCodeCave, TVariable}"/> class checks the code caves and
		///    variables for consistency, throwing an exception if there is any error found.
		/// </summary>
		/// <exception cref="UnsupportedDataTypeException">
		///    Thrown if any of the injection variables (enumerators of the type <typeparamref name="TVariable"/>) has
		///    a data type that is not supported by the RAMvader library.
		/// </exception>
		/// <exception cref="InjectorGenericParametersException">
		///    Thrown in cases where there are any errors with the generic types defined for the <see cref="Injector{TMemoryAlterationSetID, TCodeCave, TVariable}"/>.
		///    The types <typeparamref name="TMemoryAlterationSetID"/>, <typeparamref name="TCodeCave"/> and <typeparamref name="TVariable"/> MUST be enumerations.
		/// </exception>
		public Injector()
		{
			// Check the template parameters used to create the Injector instance: both must represent enumeration types.
			if ( typeof( TMemoryAlterationSetID ).IsEnum == false )
			{
				throw new InjectorGenericParametersException( string.Format(
					"[{0}] Failed to create instance. The type defined for memory alteration set identifiers was \"{1}\", while it MUST be an enumerated type!",
					GetInjectorNameWithTemplateParameters(), typeof( TMemoryAlterationSetID ).Name ) );
			}

			if ( typeof( TCodeCave ).IsEnum == false )
			{
				throw new InjectorGenericParametersException( string.Format(
					"[{0}] Failed to create instance. The type defined for code cave identifiers was \"{1}\", while it MUST be an enumerated type!",
					GetInjectorNameWithTemplateParameters(), typeof( TCodeCave ).Name ) );
			}

			if ( typeof( TVariable ).IsEnum == false )
			{
				throw new InjectorGenericParametersException( string.Format(
					"[{0}] Failed to create instance. The type defined for variable identifiers was \"{1}\", while it MUST be an enumerated type!",
					GetInjectorNameWithTemplateParameters(), typeof( TVariable ).Name ) );
			}

			// Initialize indexers.
			// IMPORTANT: That is the ONLY point where indexers are initialized. Their respective properties'
			// setter methods will NEVER alter their instance references - their only purpose is to raise
			// "property changed" notifications for the WPF Binding system whenever necessary
			m_codeCaveOffset = new NestedPropertyIndexerCodeCaveOffset( this );
			m_injectedCodeCaveAddress = new NestedPropertyIndexerInjectedCodeCaveAddress( this );
			m_variableOffset = new NestedPropertyIndexerVariableOffset( this );
			m_injectedVariableAddress = new NestedPropertyIndexerInjectedVariableAddress( this );
			m_variableSize = new NestedPropertyIndexerVariableSize( this );
		}


		/// <summary>
		///    Initializes or modifies the reference to the object used by the <see cref="Injector{TMemoryAlterationSetID, TCodeCave, TVariable}"/>
		///    to perform write operations to the target process' memory. The <see cref="Injector{TMemoryAlterationSetID, TCodeCave, TVariable}"/>
		///    also uses this object to know the endianness and pointer size of the target process.
		/// </summary>
		/// <param name="targetProc">The object used for performing memory I/O operations on the target process.</param>
		/// <seealso cref="GetTargetProcess"/>
		public void SetTargetProcess( RAMvaderTarget targetProc )
		{
			TargetProcess = targetProc;
		}


		/// <summary>
		///    Retrieves the current reference to the object used by the <see cref="Injector{TMemoryAlterationSetID, TCodeCave, TVariable}"/> to
		///    perform write operations to the target process' memory.
		///    The <see cref="Injector{TMemoryAlterationSetID, TCodeCave, TVariable}"/> also uses this object to know the endianness and pointer
		///    size of the target process.
		/// </summary>
		/// <returns>Returns the object used for performing memory I/O operations on the target process.</returns>
		/// <seealso cref="SetTargetProcess(RAMvaderTarget)"/>
		public RAMvaderTarget GetTargetProcess()
		{
			return TargetProcess;
		}


		/// <summary>Modifies the sequence of bytes used to separate two consecutive code caves.</summary>
		/// <param name="byteSeq">The new sequence of bytes to use as a separator. This can be an empty array, but should not be null.</param>
		public void SetCodeCavesSeparationBytes( byte[] byteSeq )
		{
			m_codeCavesSeparator = byteSeq;
		}


		/// <summary>Retrieves the sequence of bytes used to separate two consecutive code caves.</summary>
		/// <returns>Returns the sequence of bytes used to separate two consecutive code caves in memory.</returns>
		public byte[] GetCodeCavesSeparationBytes()
		{
			return m_codeCavesSeparator;
		}


		/// <summary>Modifies the sequence of bytes used to separate the injected code caves section from the injected variables section.</summary>
		/// <param name="byteSeq">The new sequence of bytes to use as a separator. This can be an empty array, but should not be null.</param>
		public void SetVariablesSectionSeparationBytes( byte[] byteSeq )
		{
			m_variablesSectionSeparator = byteSeq;
		}


		/// <summary>Retrieves the sequence of bytes used to separate the injected code caves section from the injected variables section.</summary>
		/// <returns>Returns the sequence of bytes used to separate two consecutive code caves in memory.</returns>
		public byte[] GetVariablesSectionSeparationBytes()
		{
			return m_variablesSectionSeparator;
		}


		/// <summary>Retrieves the address where the <see cref="Injector{TMemoryAlterationSetID, TCodeCave, TVariable}"/> has injected its data on the target process.</summary>
		/// <returns>
		///    Returns the base address where the injection has been performed.
		///    If the <see cref="Injector{TMemoryAlterationSetID, TCodeCave, TVariable}"/> didn't perform the injection yet, the return value is IntPtr.Zero.
		/// </returns>
		/// <seealso cref="Inject()"/>
		/// <seealso cref="Inject(MemoryAddress)"/>
		public IntPtr GetBaseInjectionAddress()
		{
			return BaseInjectionAddress;
		}


		/// <summary>Retrieves the offset of a given code cave, relative to the base injection address into the target process' memory space.</summary>
		/// <param name="codeCaveID">The identifier of the code cave.</param>
		/// <returns>Returns the offset of the given code cave.</returns>
		/// <exception cref="InjectionArtifactNotFoundException">Thrown when the artifact (injection variable or code cave) could not be found by the method.</exception>
		public int GetCodeCaveOffset( TCodeCave codeCaveID )
		{
			int offset = 0;
			TCodeCave [] codeCaves = (TCodeCave[]) Enum.GetValues( typeof( TCodeCave ) );

			RAMvaderTarget targetRef = this.TargetProcess;
			for ( int c = 0; c < codeCaves.Length; c++ )
			{
				// Ignore code caves that are not defined (they're considered "size zero")
				CodeCaveDefinition<TMemoryAlterationSetID,TCodeCave,TVariable> codeCaveSpecs = this.GetCodeCaveDefinition( codeCaves[c] );
				if ( codeCaveSpecs == null )
					continue;

				// Has the target code cave been found?
				if ( codeCaves[c].Equals( codeCaveID ) )
					return offset;

				// Retrieve the size of the code cave, in bytes, through its
				// specification attribute. Add the code cave's size and the
				// code cave separation bytes count to calculate the next code cave's
				// offset.
				offset += codeCaveSpecs.GetCodeCaveSize( targetRef );
				offset += m_codeCavesSeparator.Length;
			}

			throw new InjectionArtifactNotFoundException( string.Format(
				"[{0}] Cannot retrieve offset for code cave identified by \"{1}\"!",
				GetInjectorNameWithTemplateParameters(), codeCaveID.ToString() ) );
		}


		/// <summary>
		///    Retrieves the address of an injected code cave.
		///    This method should only be called after a base injection address has been defined for the <see cref="Injector{TMemoryAlterationSetID, TCodeCave, TVariable}"/>
		///    to Inject code caves and variables.
		/// </summary>
		/// <param name="codeCaveID">The identifier of the target code cave.</param>
		/// <returns>Returns the address of the given code cave, into the target process' memory space.</returns>
		/// <exception cref="InjectionArtifactNotFoundException">Thrown when the artifact (injection variable or code cave) could not be found by the method.</exception>
		public AbsoluteMemoryAddress GetInjectedCodeCaveAddress( TCodeCave codeCaveID )
		{
			if ( this.IsInjected == false )
			{
				throw new InjectionArtifactNotFoundException( string.Format(
					"[{0}] Cannot retrieve injected code cave's address (\"{1}\"): the {0} has not allocated memory into the target process yet!",
					GetInjectorNameWithTemplateParameters(), codeCaveID.ToString() ) );
			}

			return new AbsoluteMemoryAddress( BaseInjectionAddress + GetCodeCaveOffset( codeCaveID ) );
		}


		/// <summary>Retrieves the address of an injected code cave, represented as bytes stored in the target process' memory space.</summary>
		/// <param name="codeCaveID">The identifier of the target code cave.</param>
		/// <returns>
		///    Returns the array of bytes representing the address of the injected code cave, as it is to be stored into the target process'
		///    memory space.
		/// </returns>
		/// <exception cref="NullReferenceException">
		///    Thrown when the <see cref="RAMvaderTarget"/> associated with the <see cref="Injector{TMemoryAlterationSetID, TCodeCave, TVariable}"/> hasn't been set.
		///    A <see cref="RAMvaderTarget"/> instance can be associated to an <see cref="Injector{TMemoryAlterationSetID, TCodeCave, TVariable}"/> by calling
		///    the method <see cref="Injector{TMemoryAlterationSetID, TCodeCave, TVariable}.SetTargetProcess(RAMvaderTarget)"/>.
		/// </exception>
		public byte[] GetInjectedCodeCaveAddressAsBytes( TCodeCave codeCaveID )
		{
			// The target process HAS to be specified, because it is the only one who knows the target process'
			// pointers size and endianness
			if ( TargetProcess == null )
			{
				throw new NullReferenceException( string.Format(
					"Cannot retrieve the address (bytes-form) of a injected code cave: the {0} object has not been initialized with a {1}!",
					GetInjectorNameWithTemplateParameters(), typeof( RAMvaderTarget ).Name ) );
			}

			// Retrive the address (in the target process' memory space) of the injected code cave and then use
			// the RAMvaderTarget object to retrieve its byte-representation into the target process' memory space
			IntPtr caveAddress = this.GetInjectedCodeCaveAddress( codeCaveID ).Address;
			return TargetProcess.GetValueAsBytesArrayInTargetProcess( caveAddress );
		}


		/// <summary>
		///    Verifies if a given code cave has been injected by the <see cref="Injector{TMemoryAlterationSetID, TCodeCave, TVariable}"/> on
		///    the target process' memory space.
		/// </summary>
		/// <param name="caveID">The code cave whose injection needs to be verified.</param>
		/// <returns>
		///    If the <see cref="Injector{TMemoryAlterationSetID, TCodeCave, TVariable}"/> hasn't performed the injection procedure yet, or if
		///    its associated <see cref="TargetProcess"/> object isn't attached, this method returns <code>false</code>.
		///    Else, this method returns a flag specifying if the code cave has been injected. This method returns false for all code caves without
		///    a definition, as undefined injection artifacts are never injected.
		/// </returns>
		/// <exception cref="NullReferenceException">Thrown when the <see cref="TargetProcess"/> hasn't been set for this <see cref="Injector{TMemoryAlterationSetID, TCodeCave, TVariable}"/>.</exception>
		public bool IsCodeCaveInjected( TCodeCave caveID )
		{
			// Verify if the injector has an associated target process
			if ( TargetProcess == null )
				throw new NullReferenceException( string.Format( "The {0} instance is not associated to a {1} object!", GetInjectorNameWithTemplateParameters(), typeof( RAMvaderTarget ).Name ) );

			// Verify if the target process is attached, and if the injection has been performed already
			if ( TargetProcess.Attached == false || this.IsInjected == false )
				return false;

			// Try to retrieve the code cave's injection address. If an InjectionArtifactException is thrown, this means the artifact is NOT injected.
			try
			{
				this.GetInjectedCodeCaveAddress( caveID );
			}
			catch ( InjectionArtifactNotFoundException )
			{
				return false;
			}
			return true;
		}


		/// <summary>Retrieves the offset of a given variable, relative to the base injection address into the target process' memory space.</summary>
		/// <param name="varID">The identifier of the variable whose offset is to be retrieved.</param>
		/// <returns>Returns the offset to given variable.</returns>
		/// <exception cref="InjectionArtifactNotFoundException">Thrown when the artifact (injection variable or code cave) could not be found by the method.</exception>
		public int GetVariableOffset( TVariable varID )
		{
			RAMvaderTarget targetRef = this.TargetProcess;

			// Get the offset for the injected variables region in memory...
			TCodeCave [] codeCaves = (TCodeCave[]) Enum.GetValues( typeof( TCodeCave ) );
			int lastDefinedCodeCaveIndex = codeCaves.Length - 1;
			int lastDefinedCodeCaveOffset = 0, lastDefinedCodeCaveSize = 0;
			if ( codeCaves.Length > 0 )
			{
				// Find the index of the last defined code cave
				CodeCaveDefinition<TMemoryAlterationSetID,TCodeCave,TVariable> lastDefinedCodeCaveSpecs = null;
				while ( lastDefinedCodeCaveIndex >= 0 )
				{
					lastDefinedCodeCaveSpecs = this.GetCodeCaveDefinition( codeCaves[lastDefinedCodeCaveIndex] );
					if ( lastDefinedCodeCaveSpecs != null )
						break;

					lastDefinedCodeCaveIndex--;
				}

				// If the found index is valid, use it to check the offset and size of the last code cave
				if ( lastDefinedCodeCaveIndex >= 0 )
				{
					lastDefinedCodeCaveOffset = GetCodeCaveOffset( codeCaves[lastDefinedCodeCaveIndex] );
					lastDefinedCodeCaveSize = lastDefinedCodeCaveSpecs.GetCodeCaveSize( targetRef );
				}
			}

			int varOffset = lastDefinedCodeCaveOffset + lastDefinedCodeCaveSize;
			if ( lastDefinedCodeCaveIndex > 0 )
				varOffset += m_variablesSectionSeparator.Length;

			// Calculate the given variable's offset inside the injection variables' region
			foreach ( TVariable curVar in Enum.GetValues( typeof( TVariable ) ) )
			{
				// Ignore variables which haven't been defined
				VariableDefinition varSpecs = this.GetVariableDefinition( curVar );
				if ( varSpecs == null )
					continue;

				// Has the variable been found?
				if ( curVar.Equals( varID ) )
					return varOffset;

				// Move to the next variable
				varOffset += this.GetVariableSize( curVar );
			}

			throw new InjectionArtifactNotFoundException( string.Format(
				"[{0}] Cannot retrieve offset for variable identified by \"{1}\"!",
				GetInjectorNameWithTemplateParameters(), varID.ToString() ) );
		}


		/// <summary>
		///    Retrieves the address of an injected variable.
		///    This method should only be called after a base injection address has been defined for
		///    the <see cref="Injector{TMemoryAlterationSetID, TCodeCave, TVariable}"/> to Inject code caves and variables.
		/// </summary>
		/// <param name="varID">The identifier of the target variable.</param>
		/// <returns>Returns the address of the given variable, into the target process' memory space.</returns>
		/// <exception cref="InjectionArtifactNotFoundException">Thrown when the artifact (injection variable or code cave) could not be found by the method.</exception>
		public AbsoluteMemoryAddress GetInjectedVariableAddress( TVariable varID )
		{
			if ( this.IsInjected == false )
			{
				throw new InjectionArtifactNotFoundException( string.Format(
					"[{0}] Cannot retrieve injected variable's address (\"{1}\"): the {0} has not allocated memory into the target process yet!",
					GetInjectorNameWithTemplateParameters(), varID.ToString() ) );
			}
			return new AbsoluteMemoryAddress( BaseInjectionAddress + GetVariableOffset( varID ) );
		}


		/// <summary>Retrieves the address of an injected variable, represented as bytes stored in the target process' memory space.</summary>
		/// <param name="varID">The identifier of the target variable.</param>
		/// <returns>
		///    Returns the array of bytes representing the address of the injected variable, as it is to be stored into the target process'
		///    memory space.
		/// </returns>
		/// <exception cref="NullReferenceException">
		///    Thrown when the <see cref="RAMvaderTarget"/> associated with the <see cref="Injector{TMemoryAlterationSetID, TCodeCave, TVariable}"/> hasn't been set.
		///    A <see cref="RAMvaderTarget"/> instance can be associated to an <see cref="Injector{TMemoryAlterationSetID, TCodeCave, TVariable}"/> by calling
		///    the method <see cref="Injector{TMemoryAlterationSetID, TCodeCave, TVariable}.SetTargetProcess(RAMvaderTarget)"/>.
		/// </exception>
		public byte[] GetInjectedVariableAddressAsBytes( TVariable varID )
		{
			// The target process HAS to be specified, because it is the only one who knows the target process'
			// pointers size and endianness
			if ( TargetProcess == null )
			{
				throw new NullReferenceException( string.Format(
					"Cannot retrieve the address (bytes-form) of a injected variable: the {0} object has not been initialized with a {1}!",
					GetInjectorNameWithTemplateParameters(), typeof( RAMvaderTarget ).Name ) );
			}

			// Retrive the address (in the target process' memory space) of the injected variable and then use
			// the RAMvaderTarget object to retrieve its byte-representation into the target process' memory space
			IntPtr varAddress = this.GetInjectedVariableAddress( varID ).Address;
			return TargetProcess.GetValueAsBytesArrayInTargetProcess( varAddress );
		}


		/// <summary>
		///    Verifies if a given variable has been injected by the <see cref="Injector{TMemoryAlterationSetID, TCodeCave, TVariable}"/> on
		///    the target process' memory space.
		/// </summary>
		/// <param name="varID">The variable whose injection needs to be verified.</param>
		/// <returns>
		///    If the <see cref="Injector{TMemoryAlterationSetID, TCodeCave, TVariable}"/> hasn't performed the injection procedure yet, or if
		///    its associated <see cref="TargetProcess"/> object isn't attached, this method returns <code>false</code>.
		///    Else, this method returns a flag specifying if the variable has been injected. This method returns false for all variables without
		///    a definition, as undefined injection artifacts are never injected.
		/// </returns>
		/// <exception cref="NullReferenceException">Thrown when the <see cref="TargetProcess"/> hasn't been set for this <see cref="Injector{TMemoryAlterationSetID, TCodeCave, TVariable}"/>.</exception>
		public bool IsVariableInjected( TVariable varID )
		{
			// Verify if the injector has an associated target process
			if ( TargetProcess == null )
				throw new NullReferenceException( string.Format( "The {0} instance is not associated to a {1} object!", GetInjectorNameWithTemplateParameters(), typeof( RAMvaderTarget ).Name ) );

			// Verify if the target process is attached, and if the injection has been performed already
			if ( TargetProcess.Attached == false || this.IsInjected == false )
				return false;

			// Try to retrieve the variable's injection address. If an InjectionArtifactException is thrown, this means the artifact is NOT injected.
			try
			{
				this.GetInjectedVariableAddress( varID );
			}
			catch ( InjectionArtifactNotFoundException )
			{
				return false;
			}
			return true;
		}


		/// <summary>Retrieves the size of a given injection variable.</summary>
		/// <param name="varID">The identifier of the variable whose size is to be retrieved.</param>
		/// <returns>
		///    Returns the size of the given injection variable, given in bytes.
		///    If the variable has no definition set for it, the returned size is ZERO.
		/// </returns>
		/// <exception cref="NullReferenceException">
		///    Thrown when the <see cref="RAMvaderTarget"/> associated with the <see cref="Injector{TMemoryAlterationSetID, TCodeCave, TVariable}"/> hasn't been set.
		///    A <see cref="RAMvaderTarget"/> instance can be associated to an <see cref="Injector{TMemoryAlterationSetID, TCodeCave, TVariable}"/> by calling
		///    the method <see cref="Injector{TMemoryAlterationSetID, TCodeCave, TVariable}.SetTargetProcess(RAMvaderTarget)"/>.
		/// </exception>
		public int GetVariableSize( TVariable varID )
		{
			// Retrieve the type of the injection variable
			VariableDefinition injVarMetadata = this.GetVariableDefinition(varID);
			if ( injVarMetadata == null )
				return 0;
			Type varType = injVarMetadata.InitialValue.GetType();

			// Pointer types have special processing, because the target process might use either 32-bit or 64-bit pointers
			if ( varType == typeof( IntPtr ) )
			{
				// Pointer types need the target process to be initialized
				if ( TargetProcess == null )
				{
					throw new NullReferenceException( string.Format(
						"The {0} class cannot retrieve the size of an injection variable of type IntPtr before its target process is initialized!",
						GetInjectorNameWithTemplateParameters() ) );
				}

				return this.TargetProcess.GetActualTargetPointerSizeInBytes();
			}
			return RAMvaderTarget.GetSupportedDataTypeSizeInBytes( varType );
		}


		/// <summary>
		///    Calculates the total number of required bytes to inject the code caves and variables into the target process' memory space.
		///    This calculation takes in consideration the separation bytes between two consecutive code caves, the separation between the
		///    code caves section and the variables section and the size of each one of the injection variables.
		/// </summary>
		/// <returns>Returns the number of bytes required to Inject into the target process' memory.</returns>
		public int CalculateRequiredBytesCount()
		{
			int totalRequiredBytes = 0;
			RAMvaderTarget targetRef = this.TargetProcess;

			// Calculate space required for all code caves
			TCodeCave [] allCodeCaves = (TCodeCave[]) Enum.GetValues( typeof( TCodeCave ) );
			int totalDefinedCodeCaves = 0;
			foreach ( TCodeCave curCodeCave in allCodeCaves )
			{
				CodeCaveDefinition<TMemoryAlterationSetID, TCodeCave, TVariable> curCodeCaveSpecs = this.GetCodeCaveDefinition( curCodeCave );
				if ( curCodeCaveSpecs == null )
					continue;

				totalDefinedCodeCaves++;
				totalRequiredBytes += curCodeCaveSpecs.GetCodeCaveSize( targetRef );
			}

			// Calculate space required for variables
			TVariable [] allVariables = (TVariable[]) Enum.GetValues( typeof( TVariable ) );
			bool hasDefinedVariables = false;
			foreach ( TVariable curVariable in allVariables )
			{
				// Retrieve the definition of the variable, and do not process non-defined variables
				VariableDefinition varSpecs = this.GetVariableDefinition( curVariable );
				if ( varSpecs == null )
					continue;

				// Count the variable's bytes
				hasDefinedVariables = true;
				totalRequiredBytes += this.GetVariableSize( curVariable );
			}

			// Calculate space required between (consecutive) code caves
			if ( totalDefinedCodeCaves > 0 )
				totalRequiredBytes += ( totalDefinedCodeCaves - 1 ) * m_codeCavesSeparator.Length;

			// Calculate space required between the code caves section and the
			// variables section (only if there are both code caves and variables defined)
			if ( totalDefinedCodeCaves > 0 && hasDefinedVariables )
				totalRequiredBytes += m_variablesSectionSeparator.Length;

			return totalRequiredBytes;
		}


		/// <summary>
		///    Adds a memory alteration to the set of alterations related to a given identifier.
		///    Memory alteration sets are kept in as list, and this method adds a memory alteration to the end of this list.
		///    The elements of a set of memory alterations are enabled/disabled in the order they get added to the list.
		///    You can then call <see cref="SetMemoryAlterationsActive(TMemoryAlterationSetID, bool)"/> to enable or disable the whole set of alterations related to an identifier.
		/// </summary>
		/// <param name="memoryAlterationSetID">The identifier that identifies the set of alterations that can be enabled/disabled all at once.</param>
		/// <param name="memoryAlteration">An object representing the memory alteration that should be added to the given set.</param>
		public void AddMemoryAlteration( TMemoryAlterationSetID memoryAlterationSetID, MemoryAlterationBase memoryAlteration )
		{
			// Retrieve the list used to keep the given memory alterations set, creating it when necessary
			if ( m_memoryAlterationSets.ContainsKey( memoryAlterationSetID ) == false )
				m_memoryAlterationSets[memoryAlterationSetID] = new List<MemoryAlterationBase>();

			List<MemoryAlterationBase> memoryAlterationSet = m_memoryAlterationSets[memoryAlterationSetID];

			// Add alteration to the list
			memoryAlterationSet.Add( memoryAlteration );
		}


		/// <summary>
		///    Removes a memory alteration from the set of alterations related to a given identifier.
		///    Memory alteration sets are kept in as list, and this method removes a memory alteration from this list.
		///    The elements of a set of memory alterations are enabled/disabled in the order they get added to the list.
		///    You can then call <see cref="SetMemoryAlterationsActive(TMemoryAlterationSetID, bool)"/> to enable or disable the whole set of alterations related to an identifier.
		/// </summary>
		/// <param name="memoryAlterationSetID">The identifier that identifies the set of alterations that can be enabled/disabled all at once.</param>
		/// <param name="memoryAlteration">The memory alteration to be removed from the given set.</param>
		/// <returns>Returns a flag specifying if the alteration has been removed from the set.</returns>
		public bool RemoveMemoryAlteration( TMemoryAlterationSetID memoryAlterationSetID, MemoryAlterationBase memoryAlteration )
		{
			// Retrieve the list used to keep the given memory alterations set, creating it when necessary
			if ( m_memoryAlterationSets.ContainsKey( memoryAlterationSetID ) == false )
				return false;

			List<MemoryAlterationBase> memoryAlterationSet = m_memoryAlterationSets[memoryAlterationSetID];

			// Remove item form the list, removing the list if it gets empty
			bool result = memoryAlterationSet.Remove( memoryAlteration );
			if ( memoryAlterationSet.Count <= 0 )
				m_memoryAlterationSets.Remove( memoryAlterationSetID );
			return result;
		}


		/// <summary>Returns an enumerable object containing all memory alterations registered for a given memory alteration set.</summary>
		/// <param name="memoryAlterationSetID">The identifier that identifies the set of alterations that can be enabled/disabled all at once.</param>
		/// <returns>Returns an enumerable list containing all the memory alterations in the given set.</returns>
		public IEnumerable<MemoryAlterationBase> GetMemoryAlterations( TMemoryAlterationSetID memoryAlterationSetID )
		{
			if ( m_memoryAlterationSets.ContainsKey( memoryAlterationSetID ) == false )
				return new List<MemoryAlterationBase>(0);   // return an empty list
			return m_memoryAlterationSets[memoryAlterationSetID];
		}


		/// <summary>Activates or deactivates all the memory alterations registered for a given memory alterations set.</summary>
		/// <param name="memoryAlterationSetID">The identifier that identifies the set of alterations that can be enabled/disabled all at once.</param>
		/// <param name="bActivate">A flag specifying if the alterations should be activated or deactivated.</param>
		/// <returns>
		///    Returns a flag specifying if all alterations have been activated.
		///    If any of the memory alterations in a set fail to be activated/deactivated, the returned value is false.
		/// </returns>
		public bool SetMemoryAlterationsActive( TMemoryAlterationSetID memoryAlterationSetID, bool bActivate )
		{
			// If there is no alteration set with the given identifier, return true right away (nothing else to do)
			if ( m_memoryAlterationSets.ContainsKey( memoryAlterationSetID ) == false )
				return true;

			// Activate or deactivate alterations
			bool activationResult = true;
			foreach ( MemoryAlterationBase curMemoryAlteration in m_memoryAlterationSets[memoryAlterationSetID] )
			{
				if ( curMemoryAlteration.SetEnabled( this, bActivate ) == false )
					activationResult = false;
			}

			return activationResult;
		}


		/// <summary>Activates or deactivates all the memory alterations registered with the <see cref="Injector{TMemoryAlterationSetID, TCodeCave, TVariable}"/>.</summary>
		/// <param name="bActivate">A flag specifying if the alterations should be activated or deactivated.</param>
		/// <returns>
		///    Returns a flag specifying if all alterations have been activated.
		///    If any of the memory alterations in a set fail to be activated/deactivated, the returned value is false.
		/// </returns>
		public bool SetAllMemoryAlterationsActive( bool bActivate )
		{
			bool result = true;
			foreach ( TMemoryAlterationSetID curMemAlterationSet in Enum.GetValues( typeof( TMemoryAlterationSetID ) ) )
			{
				if ( this.SetMemoryAlterationsActive( curMemAlterationSet, bActivate ) == false )
					result = false;
			}

			return result;
		}


		/// <summary>
		///    Instantiates a <see cref="CodeCaveBuilder{TMemoryAlterationSetID, TCodeCave, TVariable}"/> to allow
		///    for the creation of a new code cave that can be used with this <see cref="Injector{TMemoryAlterationSetID, TCodeCave, TVariable}"/>.
		/// </summary>
		/// <returns>Returns a builder that can be used to create a new code cave for this <see cref="Injector{TMemoryAlterationSetID, TCodeCave, TVariable}"/>.</returns>
		public CodeCaveBuilder<TMemoryAlterationSetID,TCodeCave,TVariable> NewCodeCave()
		{
			return new CodeCaveBuilder<TMemoryAlterationSetID, TCodeCave, TVariable>( this );
		}


		/// <summary>
		///    Allocates memory into the target process' memory space and injects the code caves and
		///    variables into that allocated memory.
		/// </summary>
		/// <exception cref="NullReferenceException">
		///    Thrown when the <see cref="RAMvaderTarget"/> associated with the <see cref="Injector{TMemoryAlterationSetID, TCodeCave, TVariable}"/> hasn't been set.
		///    A <see cref="RAMvaderTarget"/> instance can be associated to an <see cref="Injector{TMemoryAlterationSetID, TCodeCave, TVariable}"/> by calling
		///    the method <see cref="Injector{TMemoryAlterationSetID, TCodeCave, TVariable}.SetTargetProcess(RAMvaderTarget)"/>.
		/// </exception>
		/// <exception cref="InstanceNotAttachedException">
		///    Thrown when the <see cref="RAMvaderTarget"/> instance has not been attached to a target
		///    process before the method is called.
		/// </exception>
		/// <exception cref="VirtualMemoryAllocationException">
		///    Thrown when the method cannot allocate virtual memory in the target process' memory space, to inject the data in the target process.
		///    Some softwares might implement security schemes that prevent you from allocating virtual memory on them, which in turn might require you
		///    to use manual injection of data (see <see cref="Inject(MemoryAddress)"/>).
		/// </exception>
		/// <seealso cref="GetBaseInjectionAddress"/>
		public void Inject()
		{
			// The target process should've been already defined and attached
			if ( TargetProcess == null )
				throw new NullReferenceException( String.Format( "" ) );

			if ( TargetProcess.IsAttached() == false )
				throw new InstanceNotAttachedException();

			// Allocate READ+WRITE+EXECUTE memory into the target process' memory space
			uint totalRequiredSpace = (uint) CalculateRequiredBytesCount();
			IntPtr baseInjectionAddress = IntPtr.Zero;
			if ( totalRequiredSpace != 0 )
			{
				Process targetProcessRef = TargetProcess.GetAttachedProcess();
				baseInjectionAddress = WinAPI.VirtualAllocEx(
					targetProcessRef.Handle, IntPtr.Zero, totalRequiredSpace,
					WinAPI.AllocationType.Reserve | WinAPI.AllocationType.Commit,
					WinAPI.MemoryProtection.ExecuteReadWrite );
				if ( baseInjectionAddress == IntPtr.Zero )
					throw new VirtualMemoryAllocationException();

				// Now the Injector is responsible for deallocating the allocated memory
				m_bHasAllocatedMemory = true;
			}

			// Continue with the rest of the injection procedures
			try
			{
				this.Inject( new AbsoluteMemoryAddress( baseInjectionAddress ) );
			}
			catch ( InjectorException )
			{
				// Reset the Injector's data and throw the exception up
				this.ResetAllocatedMemoryData();
				throw;
			}
		}


		/// <summary>
		///    <para>
		///       Injects the code caves and variables into the target process' memory space.
		///       This overloaded version of the <see cref="Inject()"/> method can be used to Inject the code caves into a specific point of the
		///       target process' memory space. Notice, though, that for the code caves to work correctly, they need to be injected
		///       into a memory region with appropriate permissions. Those are usually READ+WRITE+EXECUTE permissions (READ+WRITE
		///       for injected variables and EXECUTE for allowing the target process to execute the code caves). If you need to
		///       calculate the total number of bytes required by the <see cref="Injector{TMemoryAlterationSetID, TCodeCave, TVariable}"/> to inject
		///       the code caves and variables, see <see cref="CalculateRequiredBytesCount"/>.
		///    </para>
		///    <para>
		///       Notice that you should not use the <see cref="InjectedCodeCaveMemoryAddress{TMemoryAlterationSetID, TCodeCave, TVariable}"/> and <see cref="InjectedVariableMemoryAddress{TMemoryAlterationSetID, TCodeCave, TVariable}"/> classes
		///       to specify the injection point for this method, because for these classes to solve the right base address, they would require a
		///       previous injection to have happened already.
		///    </para>
		/// </summary>
		/// <param name="baseInjectionAddress">
		///    The address - into the target process' memory space - where the <see cref="Injector{TMemoryAlterationSetID, TCodeCave, TVariable}"/>
		///    will Inject the code caves and variables.
		///    A value of "IntPtr.Zero" will cause the method to exit without any effect on the target process' memory space.
		/// </param>
		/// <exception cref="NullReferenceException">
		///    Thrown when the <see cref="RAMvaderTarget"/> associated with the <see cref="Injector{TMemoryAlterationSetID, TCodeCave, TVariable}"/> hasn't been set.
		///    A <see cref="RAMvaderTarget"/> instance can be associated to an <see cref="Injector{TMemoryAlterationSetID, TCodeCave, TVariable}"/> by calling
		///    the method <see cref="Injector{TMemoryAlterationSetID, TCodeCave, TVariable}.SetTargetProcess(RAMvaderTarget)"/>.
		/// </exception>
		/// <exception cref="InstanceNotAttachedException">
		///    Thrown when the <see cref="RAMvaderTarget"/> instance has not been attached to a target
		///    process before the method is called.
		/// </exception>
		/// <exception cref="RequiredWriteException">
		///    Thrown when the <see cref="Injector{TMemoryAlterationSetID, TCodeCave, TVariable}"/> fails to write the injection
		///    data in the target process' memory space.
		/// </exception>
		/// <seealso cref="GetBaseInjectionAddress"/>
		public void Inject( MemoryAddress baseInjectionAddress )
		{
			// The target process should've been already defined and attached
			RAMvaderTarget targetRef = this.TargetProcess;
			if ( targetRef == null )
				throw new NullReferenceException( String.Format( "No target process ({0} instance) has been set for the {1}.", typeof( RAMvaderTarget ).Name, this.GetType().Name ) );

			if ( TargetProcess.IsAttached() == false )
				throw new InstanceNotAttachedException();

			// Cannot inject anything into another process' memory space if something has already been injected.
			if ( this.IsInjected )
				throw new InstanceAlreadyInjectedException();

			BaseInjectionAddress = baseInjectionAddress.Address;
			IsInjected = true;

			// Generate the bytes which constitute the data to be injected
			int totalRequiredBytes = this.CalculateRequiredBytesCount();
			List<byte> bytesToInject = new List<byte>( totalRequiredBytes );

			// Get the bytes which represent the code caves section
			bool bFirstCaveAlreadyInjected = false;
			foreach ( TCodeCave curCodeCave in Enum.GetValues( typeof( TCodeCave ) ) )
			{
				// Try to retrieve the specifications of the code cave
				CodeCaveDefinition<TMemoryAlterationSetID,TCodeCave,TVariable> caveSpecs = this.GetCodeCaveDefinition( curCodeCave );
				if ( caveSpecs == null )
					continue;

				// Add separators between two consecutive code caves
				if ( bFirstCaveAlreadyInjected )
				{
					bytesToInject.AddRange( m_codeCavesSeparator );
					m_currentInjectionOffset += m_codeCavesSeparator.Length;
				}
				bFirstCaveAlreadyInjected = true;

				// Add the bytes which represent the code cave
				byte [] generatedCodeCaveBytes = caveSpecs.GenerateCodeCaveBytes( this );

				bytesToInject.AddRange( generatedCodeCaveBytes );
				m_currentInjectionOffset += generatedCodeCaveBytes.Length;
			}

			// Add variables
			bool bFirstVariableAlreadyInjected = false;
			foreach ( TVariable curVarID in Enum.GetValues( typeof( TVariable ) ) )
			{
				// Retrieve the definition o the current variable, if any (skipping undefined variables)
				VariableDefinition varSpecs = this.GetVariableDefinition( curVarID );
				if ( varSpecs == null )
					continue;

				// Add separator from the variables section (only if one or more code caves have already been injected)
				if ( bFirstCaveAlreadyInjected &&
					bFirstVariableAlreadyInjected == false )
				{
					bytesToInject.AddRange( m_variablesSectionSeparator );
					m_currentInjectionOffset += m_variablesSectionSeparator.Length;
				}

				bFirstVariableAlreadyInjected = true;

				// Inject variable's initial value
				byte [] varInitialValueAsBytes = TargetProcess.GetValueAsBytesArrayInTargetProcess( varSpecs.InitialValue );

				bytesToInject.AddRange( varInitialValueAsBytes );
				m_currentInjectionOffset += varInitialValueAsBytes.Length;
			}

			// Inject the data!
			if ( TargetProcess.WriteToTarget( baseInjectionAddress, bytesToInject.ToArray() ) == false )
				throw new RequiredWriteException( "Failed to write injection data in the target process' memory space!" );
		}


		/// <summary>
		///    Called during the injection procedure to retrieve the number of bytes already generated by
		///    the <see cref="Injector{TMemoryAlterationSetID, TCodeCave, TVariable}"/> instance.
		///    This method is called by lower APIs which need to use the current injection position, mainly to generate
		///    instructions such as NEAR/FAR JUMPs and CALLs.
		/// </summary>
		/// <returns>
		///    <para>
		///       Returns the number of bytes that have already been generated by
		///       the <see cref="Injector{TMemoryAlterationSetID, TCodeCave, TVariable}"/> during an injection
		///       procedure.
		///    </para>
		///    <para>
		///       If the injection procedure hasn't started yet, or the <see cref="Injector{TMemoryAlterationSetID, TCodeCave, TVariable}"/>
		///       finds itself in "not injected" state, the return value is zero.
		///    </para>
		///    <para>
		///       If this method is called after a successful injection procedure, the return value is the total number of
		///       injected bytes (which is effectivelly the same result of calling <see cref="CalculateRequiredBytesCount"/>).
		///    </para>
		///    <para>
		///       If this method is called during the injection procedure (which is usually done when
		///       processing <see cref="CodeCaveArtifact{TMemoryAlterationSetID, TCodeCave, TVariable}"/> objects that compose
		///       the code caves to be injected), the return value is the total number of bytes that have been injected so far by
		///       the <see cref="Injector{TMemoryAlterationSetID, TCodeCave, TVariable}"/>.
		///    </para>
		/// </returns>
		/// <seealso cref="GetCurrentInjectionAddress"/>
		public int GetCurrentInjectionOffset()
		{
			return m_currentInjectionOffset;
		}


		/// <summary>
		///    <para>
		///       Called during the injection procedure to retrieve the address right after the last byte generated by
		///       the <see cref="Injector{TMemoryAlterationSetID, TCodeCave, TVariable}"/> instance.
		///       This method is called by lower APIs which need to use the current injection position, mainly to generate
		///       instructions such as NEAR/FAR JUMPs and CALLs.
		///    </para>
		///    <para>
		///       The return value of this method is effectivelly the sum of <see cref="BaseInjectionAddress"/> with the
		///       return value of the <see cref="GetCurrentInjectionOffset"/> method.
		///    </para>
		/// </summary>
		/// <returns>
		///       The return value of this method is effectivelly the sum of <see cref="BaseInjectionAddress"/> with the
		///       return value of the <see cref="GetCurrentInjectionOffset"/> method.
		/// </returns>
		/// <seealso cref="GetCurrentInjectionAddress"/>
		public IntPtr GetCurrentInjectionAddress()
		{
			return this.BaseInjectionAddress + this.GetCurrentInjectionOffset();
		}


		/// <summary>
		///    Resets the internal data of the <see cref="Injector{TMemoryAlterationSetID, TCodeCave, TVariable}"/> regarding the memory region where it has injected its data.
		///    This method should be called whenever the target process is terminated or whenever the <see cref="Injector{TMemoryAlterationSetID, TCodeCave, TVariable}"/> object
		///    needs to deallocate the memory it has allocated on the target process.
		/// </summary>
		public void ResetAllocatedMemoryData()
		{
			// If the Injector has allocated memory on the target process, and if the target process
			// is still running, free that allocated memory
			if ( TargetProcess != null )
			{
				Process attachedProcess = TargetProcess.GetAttachedProcess();
				if ( IsInjected && m_bHasAllocatedMemory && attachedProcess != null && attachedProcess.HasExited == false )
				{
					WinAPI.VirtualFreeEx( attachedProcess.Handle, BaseInjectionAddress, 0,
						WinAPI.FreeType.Release );
				}
			}

			// Return allocation address to zero
			BaseInjectionAddress = IntPtr.Zero;
			m_bHasAllocatedMemory = false;
			IsInjected = false;
			m_currentInjectionOffset = 0;
		}


		/// <summary>
		///    Writes a x86 CALL instruction at a specific point of the target process' memory space to enable the process' execution flow
		///    to be detoured to a specific address.
		/// </summary>
		/// <param name="detourPoint">The address of the target process' memory space where the CALL instruction will be written.</param>
		/// <param name="targetAddress">The address to where the target process' execution should be diverted.</param>
		/// <param name="instructionSize">
		///    The size of the instruction that is going to be replaced by the CALL instruction.
		///    This is used to fill the remaining bytes of the instruction with NOP opcodes, so that when the execution flows back from
		///    the CALL instruction, nothing unexpected happens.
		/// </param>
		/// <returns>Returns a flag indicating the success of the operation.</returns>
		/// <exception cref="NullReferenceException">
		///    Thrown when the <see cref="RAMvaderTarget"/> associated with the <see cref="Injector{TMemoryAlterationSetID, TCodeCave, TVariable}"/> hasn't been set.
		///    A <see cref="RAMvaderTarget"/> instance can be associated to an <see cref="Injector{TMemoryAlterationSetID, TCodeCave, TVariable}"/> by calling
		///    the method <see cref="Injector{TMemoryAlterationSetID, TCodeCave, TVariable}.SetTargetProcess(RAMvaderTarget)"/>.
		/// </exception>
		/// <exception cref="InstanceNotAttachedException">
		///    Thrown when the <see cref="RAMvaderTarget"/> instance has not been attached to a target
		///    process before the method is called.
		/// </exception>
		public bool WriteX86CallInstruction( MemoryAddress detourPoint, MemoryAddress targetAddress, int instructionSize )
		{
			// Error checking...
			if ( TargetProcess == null )
			{
				throw new NullReferenceException( string.Format(
					"[{0}] Cannot write a x86 CALL instruction: target process has not been initialized yet!",
					GetInjectorNameWithTemplateParameters() ) );
			}

			if ( TargetProcess.IsAttached() == false )
				throw new InstanceNotAttachedException();

			// Build the CALL instruction
			byte [] callOpcode = GetX86CallOpcode( detourPoint, targetAddress, instructionSize, TargetProcess.TargetProcessEndianness,
				TargetProcess.TargetPointerSize, TargetProcess.PointerSizeErrorHandling );

			// Write the instruction
			return TargetProcess.WriteToTarget( detourPoint, callOpcode );
		}


		/// <summary>
		///    Writes a x86 NEAR JUMP instruction at a specific point of the target process' memory space to enable the process'
		///    execution flow to be detoured to a specific address.
		/// </summary>
		/// <param name="jumpInstructionType">The specific type of jump instruction to be written.</param>
		/// <param name="detourPoint">The address of the target process' memory space where the JUMP instruction will be written.</param>
		/// <param name="targetAddress">The address to where the target process' execution should be diverted.</param>
		/// <param name="instructionSize">
		///    The size of the instruction that is going to be replaced by the JUMP instruction.
		///    This is used to fill the remaining bytes of the instruction with NOP opcodes, to keep the other instructions' balance
		///    unaffected by the new jump instruction.
		/// </param>
		/// <returns>Returns a flag indicating the success of the operation.</returns>
		/// <exception cref="NullReferenceException">
		///    Thrown when the <see cref="RAMvaderTarget"/> associated with the <see cref="Injector{TMemoryAlterationSetID, TCodeCave, TVariable}"/> hasn't been set.
		///    A <see cref="RAMvaderTarget"/> instance can be associated to an <see cref="Injector{TMemoryAlterationSetID, TCodeCave, TVariable}"/> by calling
		///    the method <see cref="Injector{TMemoryAlterationSetID, TCodeCave, TVariable}.SetTargetProcess(RAMvaderTarget)"/>.
		/// </exception>
		/// <exception cref="InstanceNotAttachedException">
		///    Thrown when the <see cref="RAMvaderTarget"/> instance has not been attached to a target
		///    process before the method is called.
		/// </exception>
		public bool WriteX86NearJumpInstruction( EJumpInstructionType jumpInstructionType,
			MemoryAddress detourPoint, MemoryAddress targetAddress, int instructionSize )
		{
			// Error checking...
			if ( TargetProcess == null )
			{
				throw new NullReferenceException( string.Format(
					"[{0}] Cannot write a x86 NEAR JUMP instruction: target process has not been initialized yet!",
					GetInjectorNameWithTemplateParameters() ) );
			}

			if ( TargetProcess.IsAttached() == false )
				throw new InstanceNotAttachedException();

			// Build the CALL instruction
			byte [] jumpOpcode = GetX86NearJumpOpcode( jumpInstructionType, detourPoint, targetAddress, instructionSize,
				TargetProcess.TargetPointerSize );

			// Write the instruction
			return TargetProcess.WriteToTarget( detourPoint, jumpOpcode );
		}


		/// <summary>
		///    Writes a x86 FAR JUMP instruction at a specific point of the target process' memory space to enable the process'
		///    execution flow to be detoured to a specific address.
		/// </summary>
		/// <param name="jumpInstructionType">The specific type of jump instruction to be written.</param>
		/// <param name="detourPoint">The address of the target process' memory space where the JUMP instruction will be written.</param>
		/// <param name="targetAddress">The address to where the target process' execution should be diverted.</param>
		/// <param name="instructionSize">
		///    The size of the instruction that is going to be replaced by the JUMP instruction.
		///    This is used to fill the remaining bytes of the instruction with NOP opcodes, to keep the other instructions' balance
		///    unaffected by the new jump instruction.
		/// </param>
		/// <returns>Returns a flag indicating the success of the operation.</returns>
		/// <exception cref="NullReferenceException">
		///    Thrown when the <see cref="RAMvaderTarget"/> associated with the <see cref="Injector{TMemoryAlterationSetID, TCodeCave, TVariable}"/> hasn't been set.
		///    A <see cref="RAMvaderTarget"/> instance can be associated to an <see cref="Injector{TMemoryAlterationSetID, TCodeCave, TVariable}"/> by calling
		///    the method <see cref="Injector{TMemoryAlterationSetID, TCodeCave, TVariable}.SetTargetProcess(RAMvaderTarget)"/>.
		/// </exception>
		/// <exception cref="InstanceNotAttachedException">
		///    Thrown when the <see cref="RAMvaderTarget"/> instance has not been attached to a target
		///    process before the method is called.
		/// </exception>
		public bool WriteX86FarJumpInstruction( EJumpInstructionType jumpInstructionType,
			MemoryAddress detourPoint, MemoryAddress targetAddress, int instructionSize )
		{
			// Error checking...
			if ( TargetProcess == null )
			{
				throw new NullReferenceException( string.Format(
					"[{0}] Cannot write a x86 FAR JUMP instruction: target process has not been initialized yet!",
					GetInjectorNameWithTemplateParameters() ) );
			}

			if ( TargetProcess.IsAttached() == false )
				throw new InstanceNotAttachedException();

			// Build the CALL instruction
			byte [] jumpOpcode = GetX86FarJumpOpcode( jumpInstructionType, detourPoint, targetAddress, instructionSize,
				TargetProcess.TargetProcessEndianness, TargetProcess.TargetPointerSize, TargetProcess.PointerSizeErrorHandling );

			// Write the instruction
			return TargetProcess.WriteToTarget( detourPoint, jumpOpcode );
		}


		/// <summary>
		///    Updates the value of a given variable into the target process' memory.
		///    This method is safe, as it checks the given variable's metadata against the given value's type to see if it matches
		///    the variable's type before updating the variable's value.
		/// </summary>
		/// <param name="variableID">The identifier of the injected variable whose value is to be updated.</param>
		/// <param name="newValue">The new value for the variable.</param>
		/// <returns>Returns the result of the write operation performed by a call to <see cref="RAMvaderTarget.WriteToTarget(MemoryAddress, object)"/>.</returns>
		/// <exception cref="NullReferenceException">
		///    Thrown when the <see cref="RAMvaderTarget"/> associated with the <see cref="Injector{TMemoryAlterationSetID, TCodeCave, TVariable}"/> hasn't been set.
		///    A <see cref="RAMvaderTarget"/> instance can be associated to an <see cref="Injector{TMemoryAlterationSetID, TCodeCave, TVariable}"/> by calling
		///    the method <see cref="Injector{TMemoryAlterationSetID, TCodeCave, TVariable}.SetTargetProcess(RAMvaderTarget)"/>.
		/// </exception>
		/// <exception cref="InstanceNotAttachedException">
		///    Thrown when the <see cref="RAMvaderTarget"/> instance has not been attached to a target
		///    process before the method is called.
		/// </exception>
		/// <exception cref="UnmatchedDataTypeException">Thrown when "newValue" does not match the injection variable's type.</exception>
		/// <exception cref="InjectionArtifactNotFoundException">
		///    Thrown when the variable has not been injected in the target process' memory space.
		///    This happens when the variable has no definition (<see cref="VariableDefinition"/>) registered for it with
		///    the <see cref="Injector{TMemoryAlterationSetID, TCodeCave, TVariable}"/>.
		/// </exception>
		public bool WriteVariableValue( TVariable variableID, object newValue )
		{
			// Error checking...
			if ( TargetProcess == null )
			{
				throw new NullReferenceException( string.Format(
					"[{0}] Cannot update variable's value: target process has not been initialized yet!",
					GetInjectorNameWithTemplateParameters() ) );
			}

			if ( TargetProcess.IsAttached() == false )
				throw new InstanceNotAttachedException();

			VariableDefinition varSpecs = this.GetVariableDefinition( variableID );
			if ( varSpecs == null )
				throw new InjectionArtifactNotFoundException( string.Format(
					"[{0}] Cannot update variable's value: variable identified by \"{1}\" has no variable definition associated to it!",
					GetInjectorNameWithTemplateParameters(), variableID.ToString() ) );

			Type injectedVariableType = varSpecs.InitialValue.GetType();
			Type givenValueType = newValue.GetType();
			if ( injectedVariableType != givenValueType )
				throw new UnmatchedDataTypeException( givenValueType, injectedVariableType, (Enum) (Object) variableID );

			// Update the value in the target process' memory space
			return this.TargetProcess.WriteToTarget( new InjectedVariableMemoryAddress<TMemoryAlterationSetID,TCodeCave,TVariable>( this, variableID ), newValue );
		}


		/// <summary>
		///    Reads the current value of a given variable from the target process' memory.
		///    This method is safe, as it checks the given variable's metadata against the given output variable's type to
		///    see if it matches the injected variable's type before reading the output value.
		/// </summary>
		/// <typeparam name="T">The type of the variable to be read, which must match the type of the injected variable.</typeparam>
		/// <param name="variableID">The identifier of the variable whose value is to be read from the target process' memory space.</param>
		/// <param name="outDestiny">
		///    The result of the reading will be stored in this variable.
		///    The referenced variable's data must be of the same type as declared for the variable defined in parameter <code>variableID</code>.
		/// </param>
		/// <returns>Returns the result of the read operation performed by a call to <see cref="RAMvaderTarget.ReadFromTarget{T}(MemoryAddress, ref T)"/>.</returns>
		/// <exception cref="NullReferenceException">
		///    Thrown when the <see cref="RAMvaderTarget"/> associated with the <see cref="Injector{TMemoryAlterationSetID, TCodeCave, TVariable}"/> hasn't been set.
		///    A <see cref="RAMvaderTarget"/> instance can be associated to an <see cref="Injector{TMemoryAlterationSetID, TCodeCave, TVariable}"/> by calling
		///    the method <see cref="Injector{TMemoryAlterationSetID, TCodeCave, TVariable}.SetTargetProcess(RAMvaderTarget)"/>.
		/// </exception>
		/// <exception cref="InstanceNotAttachedException">
		///    Thrown when the <see cref="RAMvaderTarget"/> instance has not been attached to a target
		///    process before the method is called.
		/// </exception>
		/// <exception cref="InjectionArtifactNotFoundException">
		///    Thrown when the variable has not been injected in the target process' memory space.
		///    This happens when the variable has no definition (<see cref="VariableDefinition"/>) registered for it with
		///    the <see cref="Injector{TMemoryAlterationSetID, TCodeCave, TVariable}"/>.
		/// </exception>
		public bool ReadVariableValue<T>( TVariable variableID, ref T outDestiny )
		{
			// Error checking...
			if ( TargetProcess == null )
			{
				throw new NullReferenceException( string.Format(
					"[{0}] Cannot read injected variable's value: target process has not been initialized yet!",
					GetInjectorNameWithTemplateParameters() ) );
			}

			if ( TargetProcess.IsAttached() == false )
				throw new InstanceNotAttachedException();

			VariableDefinition varSpecs = this.GetVariableDefinition( variableID );
			if ( varSpecs == null )
				throw new InjectionArtifactNotFoundException( string.Format(
					"[{0}] Cannot update variable's value: variable identified by \"{1}\" has no variable definition associated to it!",
					GetInjectorNameWithTemplateParameters(), variableID.ToString() ) );

			Type injectedVariableType = varSpecs.InitialValue.GetType();
			Type outputValueType = typeof(T);
			if ( injectedVariableType != outputValueType )
				throw new UnmatchedDataTypeException( outputValueType, injectedVariableType, (Enum) (Object) variableID );

			// Try to read the value from the target's memory space
			return this.TargetProcess.ReadFromTarget( new InjectedVariableMemoryAddress<TMemoryAlterationSetID,TCodeCave,TVariable>( this, variableID ), ref outDestiny );
		}


		/// <summary>
		///    <para>Updates the definition of a given code cave.</para>
		///    <para>
		///       Currently, the definitions of code caves and injection variables can only
		///       be updated when the <see cref="Injector{TMemoryAlterationSetID, TCodeCave, TVariable}"/> is
		///       in the "not injected" state.
		///    </para>
		/// </summary>
		/// <param name="caveId">The identifier of the code cave whose definition is to be updated.</param>
		/// <param name="definition">An object representing the new definition of the given code cave.</param>
		/// <exception cref="InstanceAlreadyInjectedException">
		///    Thrown when the <see cref="Injector{TMemoryAlterationSetID, TCodeCave, TVariable}"/>'s
		///    instance is already in "injected" state (this method must be called before that
		///    state is entered).
		/// </exception>
		public void SetCodeCaveDefinition( TCodeCave caveId, CodeCaveDefinition<TMemoryAlterationSetID, TCodeCave, TVariable> definition )
		{
			if ( this.IsInjected )
				throw new InstanceAlreadyInjectedException();

			m_codeCaveDefinitions[caveId] = definition;
		}


		/// <summary>
		///    <para>Updates the definition of a given injection variable.</para>
		///    <para>
		///       Currently, the definitions of code caves and injection variables can only
		///       be updated when the <see cref="Injector{TMemoryAlterationSetID, TCodeCave, TVariable}"/> is
		///       in the "not injected" state.
		///    </para>
		/// </summary>
		/// <param name="varId">The identifier of the injection variable whose definition is to be updated.</param>
		/// <param name="definition">An object representing the new definition of the given injection variable.</param>
		/// <exception cref="InstanceAlreadyInjectedException">
		///    Thrown when the <see cref="Injector{TMemoryAlterationSetID, TCodeCave, TVariable}"/>'s
		///    instance is already in "injected" state (this method must be called before that
		///    state is entered).
		/// </exception>
		/// <exception cref="UnsupportedDataTypeException">
		///    Throw when the type of the
		/// </exception>
		public void SetVariableDefinition( TVariable varId, VariableDefinition definition )
		{
			// This method should be called before the instance is injected
			if ( this.IsInjected )
				throw new InstanceAlreadyInjectedException();

			// Verify if the RAMvader library supports the given variable's type
			Type varType = definition.GetInjectionVariableType();
			if ( RAMvaderTarget.IsDataTypeSupported( varType ) == false )
				throw new UnsupportedDataTypeException( varType );

			// Update the variable's definition
			m_variableDefinitions[varId] = definition;
		}


		/// <summary>
		///    Retrieves the definition of the given code cave, that has been registered with the
		///    <see cref="Injector{TMemoryAlterationSetID, TCodeCave, TVariable}"/>, if any.
		/// </summary>
		/// <param name="caveId">The identifier of the code cave whose definition is to be retrieved.</param>
		/// <returns>
		///    <para>
		///       In case of success, returns the <see cref="CodeCaveDefinition{TMemoryAlterationSetID, TCodeCave, TVariable}"/> object
		///       representing the definition that has been registered for the given code cave.
		///    </para>
		///    <para>In case of failure, returns <code>null</code>.</para>
		/// </returns>
		public CodeCaveDefinition<TMemoryAlterationSetID, TCodeCave, TVariable> GetCodeCaveDefinition( TCodeCave caveId )
		{
			CodeCaveDefinition<TMemoryAlterationSetID,TCodeCave,TVariable> result = null;
			m_codeCaveDefinitions.TryGetValue( caveId, out result );
			return result;
		}


		/// <summary>
		///    Retrieves the definition of the given injection variable, that has been registered with the
		///    <see cref="Injector{TMemoryAlterationSetID, TCodeCave, TVariable}"/>, if any.
		/// </summary>
		/// <param name="varId">The identifier of the injection variable whose definition is to be retrieved.</param>
		/// <returns>
		///    <para>
		///       In case of success, returns the <see cref="VariableDefinition"/> object
		///       representing the definition that has been registered for the given injection variable.
		///    </para>
		///    <para>In case of failure, returns <code>null</code>.</para>
		/// </returns>
		public VariableDefinition GetVariableDefinition( TVariable varId )
		{
			VariableDefinition result = null;
			m_variableDefinitions.TryGetValue( varId, out result );
			return result;
		}


		/// <summary>
		///    <para>
		///       Clears the definition of a specific code cave, effectively making
		///       it "undefined" for
		///       the <see cref="Injector{TMemoryAlterationSetID, TCodeCave, TVariable}"/>.
		///    </para>
		///    <para>
		///       Calling this will prevent the code cave from being injected in the
		///       target process' memory space - as its definition will be voided - until it gets
		///       redefined/updated.
		///    </para>
		///    <para>
		///       Currently, the definitions of code caves and injection variables can only
		///       be updated when the <see cref="Injector{TMemoryAlterationSetID, TCodeCave, TVariable}"/> is
		///       in the "not injected" state.
		///    </para>
		/// </summary>
		/// <param name="caveId">The code cave whose definition will be cleared.</param>
		/// <returns>Returns a flag specifying if the definition has been found and removed.</returns>
		public bool ClearCodeCaveDefinition( TCodeCave caveId )
		{
			return m_codeCaveDefinitions.Remove( caveId );
		}


		/// <summary>
		///    <para>
		///       Clears the definition of a specific injection variable, effectively making
		///       it "undefined" for
		///       the <see cref="Injector{TMemoryAlterationSetID, TCodeCave, TVariable}"/>.
		///    </para>
		///    <para>
		///       Calling this will prevent the injection variable from being injected in the
		///       target process' memory space - as its definition will be voided - until it gets
		///       redefined/updated.
		///    </para>
		///    <para>
		///       Currently, the definitions of code caves and injection variables can only
		///       be updated when the <see cref="Injector{TMemoryAlterationSetID, TCodeCave, TVariable}"/> is
		///       in the "not injected" state.
		///    </para>
		/// </summary>
		/// <param name="varId">The injection variable whose definition will be cleared.</param>
		/// <returns>Returns a flag specifying if the definition has been found and removed.</returns>
		public bool ClearVariableDefinition( TVariable varId )
		{
			return m_variableDefinitions.Remove( varId );
		}


		/// <summary>
		///    <para>
		///       Clears the definition of all code caves, effectively making
		///       all of them "undefined" for
		///       the <see cref="Injector{TMemoryAlterationSetID, TCodeCave, TVariable}"/>.
		///    </para>
		///    <para>
		///       Calling this will prevent the code caves from being injected in the
		///       target process' memory space - as their definition will be voided - until they get
		///       redefined/updated.
		///    </para>
		///    <para>
		///       Currently, the definitions of code caves and injection variables can only
		///       be updated when the <see cref="Injector{TMemoryAlterationSetID, TCodeCave, TVariable}"/> is
		///       in the "not injected" state.
		///    </para>
		/// </summary>
		public void ClearAllCodeCaveDefinitions()
		{
			m_codeCaveDefinitions.Clear();
		}


		/// <summary>
		///    <para>
		///       Clears the definition of all injection varibles, effectively making
		///       all of them "undefined" for
		///       the <see cref="Injector{TMemoryAlterationSetID, TCodeCave, TVariable}"/>.
		///    </para>
		///    <para>
		///       Calling this will prevent the injection variables from being injected in the
		///       target process' memory space - as their definition will be voided - until they get
		///       redefined/updated.
		///    </para>
		///    <para>
		///       Currently, the definitions of code caves and injection variables can only
		///       be updated when the <see cref="Injector{TMemoryAlterationSetID, TCodeCave, TVariable}"/> is
		///       in the "not injected" state.
		///    </para>
		/// </summary>
		public void ClearAllVariableDefinitions()
		{
			m_variableDefinitions.Clear();
		}
		#endregion
	}
}
