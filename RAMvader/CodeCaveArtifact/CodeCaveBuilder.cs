/*
 * Copyright (C) 2014 Vinicius Rogério Araujo Silva
 *
 * This file is part of RAMvader.
 *
 * RAMvader is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * RAMvader is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with RAMvader.  If not, see <http://www.gnu.org/licenses/>.
 */

using System;
using System.Collections.Generic;

namespace RAMvader.CodeInjection
{
    /// <summary>
    ///    <para>
    ///       A class specialized in building <see cref="CodeCaveDefinition{TMemoryAlterationSetID, TCodeCave, TVariable}"/> objects.
    ///       This class follows a fluid design pattern, allowing calls to its code cave construction-related methods to
    ///       be cascaded, making code easier to read and maintain.
    ///    </para>
    ///    <para>
    ///       Under the hoods, this class generates <see cref="CodeCaveArtifact{TMemoryAlterationSetID, TCodeCave, TVariable}"/> objects,
    ///       which are kept in a list that can be used to generate the code cave definition.
    ///    </para>
    ///    <para>
    ///    </para>
    /// </summary>
    public class CodeCaveBuilder<TMemoryAlterationSetID, TCodeCave, TVariable>
	{
		#region PRIVATE FIELDS
		/// <summary>
		///    A reference to the <see cref="Injector{TMemoryAlterationSetID, TCodeCave, TVariable}"/> object to which
		///    the <see cref="CodeCaveDefinition{TMemoryAlterationSetID, TCodeCave, TVariable}"/> objects will be created.
		/// </summary>
		private Injector<TMemoryAlterationSetID, TCodeCave, TVariable> m_injector;
		/// <summary>The list of artifacts that have currently been generated by the <see cref="CodeCaveBuilder{TMemoryAlterationSetID, TCodeCave, TVariable}"/>.</summary>
		private List<CodeCaveArtifact<TMemoryAlterationSetID, TCodeCave, TVariable>> m_artifacts = new List<CodeCaveArtifact<TMemoryAlterationSetID, TCodeCave, TVariable>>();
		#endregion





		#region PUBLIC METHODS
		/// <summary>Constructor.</summary>
		/// <param name="injector">
		///    A reference to the <see cref="Injector{TMemoryAlterationSetID, TCodeCave, TVariable}"/> object to which
		///    the <see cref="CodeCaveDefinition{TMemoryAlterationSetID, TCodeCave, TVariable}"/> objects will be created.
		/// </param>
		public CodeCaveBuilder( Injector<TMemoryAlterationSetID,TCodeCave,TVariable> injector )
		{
			m_injector = injector;
		}


		/// <summary>
		///    Called as the last step for building a <see cref="CodeCaveDefinition{TMemoryAlterationSetID, TCodeCave, TVariable}"/>,
		///    returning the produced definition.
		/// </summary>
		/// <returns>Returns the created <see cref="CodeCaveDefinition{TMemoryAlterationSetID, TCodeCave, TVariable}"/> instance.</returns>
		public CodeCaveDefinition<TMemoryAlterationSetID, TCodeCave, TVariable> Build()
		{
			var result = new CodeCaveDefinition<TMemoryAlterationSetID, TCodeCave, TVariable>();

			var artifactsList = this.m_artifacts.ToArray();
			result.SetArtifactsArray( artifactsList );

			return result;
		}


		/// <summary>
		///    Adds the bytes that represent the address of an injected code cave to the code cave being built.
		///    This effectivelly adds a <see cref="CodeCaveArtifactVariableAddress{TMemoryAlterationSetID, TCodeCave, TVariable}"/>
		///    artifact to the list of generated artifacts.
		/// </summary>
		/// <param name="varId">The identifier of the variable whose address will be added.</param>
		/// <returns>Returns a reference to the object used to call the method.</returns>
		public CodeCaveBuilder<TMemoryAlterationSetID, TCodeCave, TVariable> VarAddr( TVariable varId )
		{
			m_artifacts.Add( new CodeCaveArtifactVariableAddress<TMemoryAlterationSetID, TCodeCave, TVariable>( varId ) );
			return this;
		}


		/// <summary>
		///    Adds the bytes that represent the address of an injected variable to the code cave being built.
		///    This effectivelly adds a <see cref="CodeCaveArtifactCodeCaveAddress{TMemoryAlterationSetID, TCodeCave, TVariable}"/>
		///    artifact to the list of generated artifacts.
		/// </summary>
		/// <param name="caveId">The identifier of the code cave whose address will be added.</param>
		/// <returns>Returns a reference to the object used to call the method.</returns>
		public CodeCaveBuilder<TMemoryAlterationSetID, TCodeCave, TVariable> CaveAddr( TCodeCave caveId )
		{
			m_artifacts.Add( new CodeCaveArtifactCodeCaveAddress<TMemoryAlterationSetID, TCodeCave, TVariable>( caveId ) );
			return this;
		}


		/// <summary>
		///    Adds the given sequence of signed bytes (<see cref="SByte"/>) to the code cave being built.
		///    This effectivelly adds a <see cref="CodeCaveArtifactSByteSequence{TMemoryAlterationSetID, TCodeCave, TVariable}"/>
		///    artifact to the list of generated artifacts.
		/// </summary>
		/// <param name="bytes">The sequence of (signed) bytes which will be added.</param>
		/// <returns>Returns a reference to the object used to call the method.</returns>
		public CodeCaveBuilder<TMemoryAlterationSetID, TCodeCave, TVariable> SBytes( params sbyte[] bytes )
		{
			m_artifacts.Add( new CodeCaveArtifactSByteSequence<TMemoryAlterationSetID, TCodeCave, TVariable>( bytes ) );
			return this;
		}


		/// <summary>
		///    Adds the given sequence of unsigned bytes (<see cref="Byte"/>) to the code cave being built.
		///    This effectivelly adds a <see cref="CodeCaveArtifactByteSequence{TMemoryAlterationSetID, TCodeCave, TVariable}"/>
		///    artifact to the list of generated artifacts.
		/// </summary>
		/// <param name="bytes">The sequence of (unsigned) bytes which will be added.</param>
		/// <returns>Returns a reference to the object used to call the method.</returns>
		public CodeCaveBuilder<TMemoryAlterationSetID, TCodeCave, TVariable> Bytes( params byte[] bytes )
		{
			m_artifacts.Add( new CodeCaveArtifactByteSequence<TMemoryAlterationSetID, TCodeCave, TVariable>( bytes ) );
			return this;
		}


        /// <summary>
        ///    Adds the bytes corresponding to an x86 branch instruction to the code cave being built.
        ///    This effectivelly adds a <see cref="CodeCaveArtifactX86BranchInstruction{TMemoryAlterationSetID, TCodeCave, TVariable}"/>
        ///    artifact to the list of generated artifacts.
        /// </summary>
        /// <param name="instructionType">The type of branch instruction to be generated.</param>
        /// <param name="targetAddress">The target address of the branching instruction.</param>
        /// <returns>Returns a reference to the object used to call the method.</returns>
        public CodeCaveBuilder<TMemoryAlterationSetID, TCodeCave, TVariable> X86Branch(EX86BranchInstructionType instructionType, MemoryAddress targetAddress)
        {
            m_artifacts.Add(new CodeCaveArtifactX86BranchInstruction<TMemoryAlterationSetID, TCodeCave, TVariable>(instructionType, targetAddress));
            return this;
        }
		#endregion
	}
}
