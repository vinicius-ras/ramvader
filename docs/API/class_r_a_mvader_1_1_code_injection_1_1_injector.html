<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>RAMvader: RAMvader.CodeInjection.Injector&lt; TMemoryAlterationSetID, TCodeCave, TVariable &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="icon.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">RAMvader
   &#160;<span id="projectnumber">1.4</span>
   </div>
   <div id="projectbrief">A .NET library which provides access to other processes&#39; memory space.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('class_r_a_mvader_1_1_code_injection_1_1_injector.html','');});
/* @license-end */
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#properties">Properties</a> &#124;
<a href="class_r_a_mvader_1_1_code_injection_1_1_injector-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">RAMvader.CodeInjection.Injector&lt; TMemoryAlterationSetID, TCodeCave, TVariable &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Implements the logic behind the injection of code caves and variables into a target process' memory space.  
 <a href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#details">More...</a></p>

<p>Inherits <a class="el" href="class_r_a_mvader_1_1_notify_property_changed_adapter.html">RAMvader.NotifyPropertyChangedAdapter</a>.</p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a419370074a281efc1ead6d988da539eb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#a419370074a281efc1ead6d988da539eb">Injector</a> ()</td></tr>
<tr class="memdesc:a419370074a281efc1ead6d988da539eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor. The constructor of the <a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#a419370074a281efc1ead6d988da539eb" title="Constructor. The constructor of the Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt; class chec...">Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt;</a> class checks the code caves and variables for consistency, throwing an exception if there is any error found.  <a href="#a419370074a281efc1ead6d988da539eb">More...</a><br /></td></tr>
<tr class="separator:a419370074a281efc1ead6d988da539eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad901aa5384b7e4f5c87362003c432e6f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#ad901aa5384b7e4f5c87362003c432e6f">SetTargetProcess</a> (<a class="el" href="class_r_a_mvader_1_1_target.html">Target</a> targetProc)</td></tr>
<tr class="memdesc:ad901aa5384b7e4f5c87362003c432e6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes or modifies the reference to the object used by the <a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#a419370074a281efc1ead6d988da539eb" title="Constructor. The constructor of the Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt; class chec...">Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt;</a> to perform write operations to the target process' memory. The <a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#a419370074a281efc1ead6d988da539eb" title="Constructor. The constructor of the Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt; class chec...">Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt;</a> also uses this object to know the endianness and pointer size of the target process.  <a href="#ad901aa5384b7e4f5c87362003c432e6f">More...</a><br /></td></tr>
<tr class="separator:ad901aa5384b7e4f5c87362003c432e6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f3a5f9dbe3bf46fa64c3d856d553b78"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_r_a_mvader_1_1_target.html">Target</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#a8f3a5f9dbe3bf46fa64c3d856d553b78">GetTargetProcess</a> ()</td></tr>
<tr class="memdesc:a8f3a5f9dbe3bf46fa64c3d856d553b78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the current reference to the object used by the <a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#a419370074a281efc1ead6d988da539eb" title="Constructor. The constructor of the Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt; class chec...">Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt;</a> to perform write operations to the target process' memory. The <a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#a419370074a281efc1ead6d988da539eb" title="Constructor. The constructor of the Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt; class chec...">Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt;</a> also uses this object to know the endianness and pointer size of the target process.  <a href="#a8f3a5f9dbe3bf46fa64c3d856d553b78">More...</a><br /></td></tr>
<tr class="separator:a8f3a5f9dbe3bf46fa64c3d856d553b78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ed24d89ef5afd453fdf1bd473b7493c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#a3ed24d89ef5afd453fdf1bd473b7493c">SetCodeCavesSeparationBytes</a> (params byte[] byteSeq)</td></tr>
<tr class="memdesc:a3ed24d89ef5afd453fdf1bd473b7493c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modifies the sequence of bytes used to separate two consecutive code caves. <a href="#a3ed24d89ef5afd453fdf1bd473b7493c">More...</a><br /></td></tr>
<tr class="separator:a3ed24d89ef5afd453fdf1bd473b7493c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab126ed7ad623179815ee82e0b8a3a71b"><td class="memItemLeft" align="right" valign="top">byte []&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#ab126ed7ad623179815ee82e0b8a3a71b">GetCodeCavesSeparationBytes</a> ()</td></tr>
<tr class="memdesc:ab126ed7ad623179815ee82e0b8a3a71b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the sequence of bytes used to separate two consecutive code caves. <a href="#ab126ed7ad623179815ee82e0b8a3a71b">More...</a><br /></td></tr>
<tr class="separator:ab126ed7ad623179815ee82e0b8a3a71b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25f2c1decddf86048b6ee93e44a2f122"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#a25f2c1decddf86048b6ee93e44a2f122">SetVariablesSectionSeparationBytes</a> (params byte[] byteSeq)</td></tr>
<tr class="memdesc:a25f2c1decddf86048b6ee93e44a2f122"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modifies the sequence of bytes used to separate the injected code caves section from the injected variables section. <a href="#a25f2c1decddf86048b6ee93e44a2f122">More...</a><br /></td></tr>
<tr class="separator:a25f2c1decddf86048b6ee93e44a2f122"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8b26ea98ec4cf0c8fc5755a81467150"><td class="memItemLeft" align="right" valign="top">byte []&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#af8b26ea98ec4cf0c8fc5755a81467150">GetVariablesSectionSeparationBytes</a> ()</td></tr>
<tr class="memdesc:af8b26ea98ec4cf0c8fc5755a81467150"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the sequence of bytes used to separate the injected code caves section from the injected variables section. <a href="#af8b26ea98ec4cf0c8fc5755a81467150">More...</a><br /></td></tr>
<tr class="separator:af8b26ea98ec4cf0c8fc5755a81467150"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7841dd7b14a8cbb993633712b968799"><td class="memItemLeft" align="right" valign="top">IntPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#aa7841dd7b14a8cbb993633712b968799">GetBaseInjectionAddress</a> ()</td></tr>
<tr class="memdesc:aa7841dd7b14a8cbb993633712b968799"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the address where the <a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#a419370074a281efc1ead6d988da539eb" title="Constructor. The constructor of the Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt; class chec...">Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt;</a> has injected its data on the target process. <a href="#aa7841dd7b14a8cbb993633712b968799">More...</a><br /></td></tr>
<tr class="separator:aa7841dd7b14a8cbb993633712b968799"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbe434daacbcc5f9f2199c55310bd3fc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#afbe434daacbcc5f9f2199c55310bd3fc">GetCodeCaveOffset</a> (TCodeCave codeCaveID)</td></tr>
<tr class="memdesc:afbe434daacbcc5f9f2199c55310bd3fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the offset of a given code cave, relative to the base injection address into the target process' memory space. <a href="#afbe434daacbcc5f9f2199c55310bd3fc">More...</a><br /></td></tr>
<tr class="separator:afbe434daacbcc5f9f2199c55310bd3fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9467a81ecc9e38bc95abe2dd42ebd767"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_r_a_mvader_1_1_absolute_memory_address.html">AbsoluteMemoryAddress</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#a9467a81ecc9e38bc95abe2dd42ebd767">GetInjectedCodeCaveAddress</a> (TCodeCave codeCaveID)</td></tr>
<tr class="memdesc:a9467a81ecc9e38bc95abe2dd42ebd767"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the address of an injected code cave. This method should only be called after a base injection address has been defined for the <a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#a419370074a281efc1ead6d988da539eb" title="Constructor. The constructor of the Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt; class chec...">Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt;</a> to Inject code caves and variables.  <a href="#a9467a81ecc9e38bc95abe2dd42ebd767">More...</a><br /></td></tr>
<tr class="separator:a9467a81ecc9e38bc95abe2dd42ebd767"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c66ac1bd59455147dc47caf6f69c895"><td class="memItemLeft" align="right" valign="top">byte []&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#a8c66ac1bd59455147dc47caf6f69c895">GetInjectedCodeCaveAddressAsBytes</a> (TCodeCave codeCaveID)</td></tr>
<tr class="memdesc:a8c66ac1bd59455147dc47caf6f69c895"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the address of an injected code cave, represented as bytes stored in the target process' memory space. <a href="#a8c66ac1bd59455147dc47caf6f69c895">More...</a><br /></td></tr>
<tr class="separator:a8c66ac1bd59455147dc47caf6f69c895"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fe29aeeff7b94a0d0898296cd5f80d1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#a6fe29aeeff7b94a0d0898296cd5f80d1">IsCodeCaveInjected</a> (TCodeCave caveID)</td></tr>
<tr class="memdesc:a6fe29aeeff7b94a0d0898296cd5f80d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verifies if a given code cave has been injected by the <a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#a419370074a281efc1ead6d988da539eb" title="Constructor. The constructor of the Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt; class chec...">Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt;</a> on the target process' memory space.  <a href="#a6fe29aeeff7b94a0d0898296cd5f80d1">More...</a><br /></td></tr>
<tr class="separator:a6fe29aeeff7b94a0d0898296cd5f80d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ac14f4ef2ba785e139cf4f937b3b000"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#a6ac14f4ef2ba785e139cf4f937b3b000">GetVariableOffset</a> (TVariable varID)</td></tr>
<tr class="memdesc:a6ac14f4ef2ba785e139cf4f937b3b000"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the offset of a given variable, relative to the base injection address into the target process' memory space. <a href="#a6ac14f4ef2ba785e139cf4f937b3b000">More...</a><br /></td></tr>
<tr class="separator:a6ac14f4ef2ba785e139cf4f937b3b000"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0de69746ab2fe19093d38aacd01bdada"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_r_a_mvader_1_1_absolute_memory_address.html">AbsoluteMemoryAddress</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#a0de69746ab2fe19093d38aacd01bdada">GetInjectedVariableAddress</a> (TVariable varID)</td></tr>
<tr class="memdesc:a0de69746ab2fe19093d38aacd01bdada"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the address of an injected variable. This method should only be called after a base injection address has been defined for the <a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#a419370074a281efc1ead6d988da539eb" title="Constructor. The constructor of the Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt; class chec...">Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt;</a> to Inject code caves and variables.  <a href="#a0de69746ab2fe19093d38aacd01bdada">More...</a><br /></td></tr>
<tr class="separator:a0de69746ab2fe19093d38aacd01bdada"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeea87db151126ba604fe2e9f5ddd92d2"><td class="memItemLeft" align="right" valign="top">byte []&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#aeea87db151126ba604fe2e9f5ddd92d2">GetInjectedVariableAddressAsBytes</a> (TVariable varID)</td></tr>
<tr class="memdesc:aeea87db151126ba604fe2e9f5ddd92d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the address of an injected variable, represented as bytes stored in the target process' memory space. <a href="#aeea87db151126ba604fe2e9f5ddd92d2">More...</a><br /></td></tr>
<tr class="separator:aeea87db151126ba604fe2e9f5ddd92d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdd8dadeaac352e221b9ea5e5a884434"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#acdd8dadeaac352e221b9ea5e5a884434">IsVariableInjected</a> (TVariable varID)</td></tr>
<tr class="memdesc:acdd8dadeaac352e221b9ea5e5a884434"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verifies if a given variable has been injected by the <a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#a419370074a281efc1ead6d988da539eb" title="Constructor. The constructor of the Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt; class chec...">Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt;</a> on the target process' memory space.  <a href="#acdd8dadeaac352e221b9ea5e5a884434">More...</a><br /></td></tr>
<tr class="separator:acdd8dadeaac352e221b9ea5e5a884434"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a851b55538b48bb2292b2a4553fffd313"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#a851b55538b48bb2292b2a4553fffd313">GetVariableSize</a> (TVariable varID)</td></tr>
<tr class="memdesc:a851b55538b48bb2292b2a4553fffd313"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the size of a given injection variable. <a href="#a851b55538b48bb2292b2a4553fffd313">More...</a><br /></td></tr>
<tr class="separator:a851b55538b48bb2292b2a4553fffd313"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afca31c63dacc7873439b66908ef84714"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#afca31c63dacc7873439b66908ef84714">CalculateRequiredBytesCount</a> ()</td></tr>
<tr class="memdesc:afca31c63dacc7873439b66908ef84714"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the total number of required bytes to inject the code caves and variables into the target process' memory space. This calculation takes in consideration the separation bytes between two consecutive code caves, the separation between the code caves section and the variables section and the size of each one of the injection variables.  <a href="#afca31c63dacc7873439b66908ef84714">More...</a><br /></td></tr>
<tr class="separator:afca31c63dacc7873439b66908ef84714"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7afd16f94510d4786682161612718889"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#a7afd16f94510d4786682161612718889">AddMemoryAlteration</a> (TMemoryAlterationSetID memoryAlterationSetID, <a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_memory_alteration_base.html">MemoryAlterationBase</a> memoryAlteration)</td></tr>
<tr class="memdesc:a7afd16f94510d4786682161612718889"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a memory alteration to the set of alterations related to a given identifier. Memory alteration sets are kept in as list, and this method adds a memory alteration to the end of this list. The elements of a set of memory alterations are enabled/disabled in the order they get added to the list. You can then call <a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#a424976a64ff18332548d98c4fc603f74" title="Activates or deactivates all the memory alterations registered for a given memory alterations set...">SetMemoryAlterationsActive(TMemoryAlterationSetID, bool)</a> to enable or disable the whole set of alterations related to an identifier.  <a href="#a7afd16f94510d4786682161612718889">More...</a><br /></td></tr>
<tr class="separator:a7afd16f94510d4786682161612718889"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a968f4ba0e6c9f717907c81e439a51675"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#a968f4ba0e6c9f717907c81e439a51675">RemoveMemoryAlteration</a> (TMemoryAlterationSetID memoryAlterationSetID, <a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_memory_alteration_base.html">MemoryAlterationBase</a> memoryAlteration)</td></tr>
<tr class="memdesc:a968f4ba0e6c9f717907c81e439a51675"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a memory alteration from the set of alterations related to a given identifier. Memory alteration sets are kept in as list, and this method removes a memory alteration from this list. The elements of a set of memory alterations are enabled/disabled in the order they get added to the list. You can then call <a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#a424976a64ff18332548d98c4fc603f74" title="Activates or deactivates all the memory alterations registered for a given memory alterations set...">SetMemoryAlterationsActive(TMemoryAlterationSetID, bool)</a> to enable or disable the whole set of alterations related to an identifier.  <a href="#a968f4ba0e6c9f717907c81e439a51675">More...</a><br /></td></tr>
<tr class="separator:a968f4ba0e6c9f717907c81e439a51675"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39a81acaf6e8604bc4b536b17cef103b"><td class="memItemLeft" align="right" valign="top">IEnumerable&lt; <a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_memory_alteration_base.html">MemoryAlterationBase</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#a39a81acaf6e8604bc4b536b17cef103b">GetMemoryAlterations</a> (TMemoryAlterationSetID memoryAlterationSetID)</td></tr>
<tr class="memdesc:a39a81acaf6e8604bc4b536b17cef103b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an enumerable object containing all memory alterations registered for a given memory alteration set. <a href="#a39a81acaf6e8604bc4b536b17cef103b">More...</a><br /></td></tr>
<tr class="separator:a39a81acaf6e8604bc4b536b17cef103b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a424976a64ff18332548d98c4fc603f74"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#a424976a64ff18332548d98c4fc603f74">SetMemoryAlterationsActive</a> (TMemoryAlterationSetID memoryAlterationSetID, bool bActivate)</td></tr>
<tr class="memdesc:a424976a64ff18332548d98c4fc603f74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Activates or deactivates all the memory alterations registered for a given memory alterations set. <a href="#a424976a64ff18332548d98c4fc603f74">More...</a><br /></td></tr>
<tr class="separator:a424976a64ff18332548d98c4fc603f74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ae5cd06168e3dc0130d69115722a0eb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#a8ae5cd06168e3dc0130d69115722a0eb">SetAllMemoryAlterationsActive</a> (bool bActivate)</td></tr>
<tr class="memdesc:a8ae5cd06168e3dc0130d69115722a0eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Activates or deactivates all the memory alterations registered with the <a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#a419370074a281efc1ead6d988da539eb" title="Constructor. The constructor of the Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt; class chec...">Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt;</a>. <a href="#a8ae5cd06168e3dc0130d69115722a0eb">More...</a><br /></td></tr>
<tr class="separator:a8ae5cd06168e3dc0130d69115722a0eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf1e6af657393826a1cfeb99a4b94897"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_code_cave_builder.html">CodeCaveBuilder</a>&lt; TMemoryAlterationSetID, TCodeCave, TVariable &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#abf1e6af657393826a1cfeb99a4b94897">NewCodeCave</a> ()</td></tr>
<tr class="memdesc:abf1e6af657393826a1cfeb99a4b94897"><td class="mdescLeft">&#160;</td><td class="mdescRight">Instantiates a CodeCaveBuilder&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt; to allow for the creation of a new code cave that can be used with this <a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#a419370074a281efc1ead6d988da539eb" title="Constructor. The constructor of the Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt; class chec...">Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt;</a>.  <a href="#abf1e6af657393826a1cfeb99a4b94897">More...</a><br /></td></tr>
<tr class="separator:abf1e6af657393826a1cfeb99a4b94897"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96b48ff9f2c0bb415c94810299982159"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#a96b48ff9f2c0bb415c94810299982159">Inject</a> ()</td></tr>
<tr class="memdesc:a96b48ff9f2c0bb415c94810299982159"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates memory into the target process' memory space and injects the code caves and variables into that allocated memory.  <a href="#a96b48ff9f2c0bb415c94810299982159">More...</a><br /></td></tr>
<tr class="separator:a96b48ff9f2c0bb415c94810299982159"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75bba917eadc2711528f672d7cd536bf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#a75bba917eadc2711528f672d7cd536bf">Inject</a> (<a class="el" href="class_r_a_mvader_1_1_memory_address.html">MemoryAddress</a> baseInjectionAddress)</td></tr>
<tr class="separator:a75bba917eadc2711528f672d7cd536bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a188e8fc2fe061ad60898feeb1de21831"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#a188e8fc2fe061ad60898feeb1de21831">GetCurrentInjectionOffset</a> ()</td></tr>
<tr class="memdesc:a188e8fc2fe061ad60898feeb1de21831"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called during the injection procedure to retrieve the number of bytes already generated by the <a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#a419370074a281efc1ead6d988da539eb" title="Constructor. The constructor of the Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt; class chec...">Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt;</a> instance. This method is called by lower APIs which need to use the current injection position, mainly to generate branching instructions (which need to know their exact address when they need to be generated).  <a href="#a188e8fc2fe061ad60898feeb1de21831">More...</a><br /></td></tr>
<tr class="separator:a188e8fc2fe061ad60898feeb1de21831"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a529dd9750b1d40ed71cbed74fd2d1a40"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#a529dd9750b1d40ed71cbed74fd2d1a40">IncreaseCurrentInjectionOffset</a> (int increase)</td></tr>
<tr class="memdesc:a529dd9750b1d40ed71cbed74fd2d1a40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called during the injection procedure to increase the number of bytes already generated by the <a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#a419370074a281efc1ead6d988da539eb" title="Constructor. The constructor of the Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt; class chec...">Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt;</a> instance. This method is called by lower APIs to inform changes which should be made in the current injection position, mainly to allow for the generation branching instructions (which need to know their exact address when they need to be generated).  <a href="#a529dd9750b1d40ed71cbed74fd2d1a40">More...</a><br /></td></tr>
<tr class="separator:a529dd9750b1d40ed71cbed74fd2d1a40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a529713eb9304f7733060269ca4aa663a"><td class="memItemLeft" align="right" valign="top">IntPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#a529713eb9304f7733060269ca4aa663a">GetCurrentInjectionAddress</a> ()</td></tr>
<tr class="separator:a529713eb9304f7733060269ca4aa663a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae718ee1ec135b8b74709770d87829bef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#ae718ee1ec135b8b74709770d87829bef">ResetAllocatedMemoryData</a> ()</td></tr>
<tr class="memdesc:ae718ee1ec135b8b74709770d87829bef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the internal data of the <a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#a419370074a281efc1ead6d988da539eb" title="Constructor. The constructor of the Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt; class chec...">Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt;</a> regarding the memory region where it has injected its data. This method should be called whenever the target process is terminated or whenever the <a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#a419370074a281efc1ead6d988da539eb" title="Constructor. The constructor of the Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt; class chec...">Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt;</a> object needs to deallocate the memory it has allocated on the target process.  <a href="#ae718ee1ec135b8b74709770d87829bef">More...</a><br /></td></tr>
<tr class="separator:ae718ee1ec135b8b74709770d87829bef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d6e715c35dbe9d30390974ca3fc6666"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#a9d6e715c35dbe9d30390974ca3fc6666">WriteX86BranchInstruction</a> (<a class="el" href="namespace_r_a_mvader.html#a9e2b14ce7eb13c552fd5175e8b3d7d44">EX86BranchInstructionType</a> instructionType, <a class="el" href="class_r_a_mvader_1_1_memory_address.html">MemoryAddress</a> branchPoint, <a class="el" href="class_r_a_mvader_1_1_memory_address.html">MemoryAddress</a> targetAddress, int instructionSize=X86Constants.INSTRUCTION_SIZE_ANY)</td></tr>
<tr class="memdesc:a9d6e715c35dbe9d30390974ca3fc6666"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a x86 branch instruction at a specific point of the target process' memory space to enable the process' execution flow to be branched to another specific address.  <a href="#a9d6e715c35dbe9d30390974ca3fc6666">More...</a><br /></td></tr>
<tr class="separator:a9d6e715c35dbe9d30390974ca3fc6666"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab53889e9bdbcbdd0ea99669840f528a7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#ab53889e9bdbcbdd0ea99669840f528a7">WriteVariableValue</a> (TVariable variableID, object newValue)</td></tr>
<tr class="memdesc:ab53889e9bdbcbdd0ea99669840f528a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the value of a given variable into the target process' memory. This method is safe, as it checks the given variable's metadata against the given value's type to see if it matches the variable's type before updating the variable's value.  <a href="#ab53889e9bdbcbdd0ea99669840f528a7">More...</a><br /></td></tr>
<tr class="separator:ab53889e9bdbcbdd0ea99669840f528a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada27879a75035a2c4517f397c2591d8c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#ada27879a75035a2c4517f397c2591d8c">ReadVariableValue&lt; T &gt;</a> (TVariable variableID, ref T outDestiny)</td></tr>
<tr class="memdesc:ada27879a75035a2c4517f397c2591d8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the current value of a given variable from the target process' memory. This method is safe, as it checks the given variable's metadata against the given output variable's type to see if it matches the injected variable's type before reading the output value.  <a href="#ada27879a75035a2c4517f397c2591d8c">More...</a><br /></td></tr>
<tr class="separator:ada27879a75035a2c4517f397c2591d8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af70129163be21cd5b4efddab923a9740"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#af70129163be21cd5b4efddab923a9740">SetCodeCaveDefinition</a> (TCodeCave caveId, <a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_code_cave_definition.html">CodeCaveDefinition</a>&lt; TMemoryAlterationSetID, TCodeCave, TVariable &gt; definition)</td></tr>
<tr class="separator:af70129163be21cd5b4efddab923a9740"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ef8e379cc7b256b418617e03ba2b591"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#a5ef8e379cc7b256b418617e03ba2b591">SetVariableDefinition</a> (TVariable varId, <a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_variable_definition.html">VariableDefinition</a> definition)</td></tr>
<tr class="separator:a5ef8e379cc7b256b418617e03ba2b591"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c62aeb3187547262ccb76672bbc4927"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_code_cave_definition.html">CodeCaveDefinition</a>&lt; TMemoryAlterationSetID, TCodeCave, TVariable &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#a3c62aeb3187547262ccb76672bbc4927">GetCodeCaveDefinition</a> (TCodeCave caveId)</td></tr>
<tr class="memdesc:a3c62aeb3187547262ccb76672bbc4927"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the definition of the given code cave, that has been registered with the <a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#a419370074a281efc1ead6d988da539eb" title="Constructor. The constructor of the Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt; class chec...">Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt;</a>, if any.  <a href="#a3c62aeb3187547262ccb76672bbc4927">More...</a><br /></td></tr>
<tr class="separator:a3c62aeb3187547262ccb76672bbc4927"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93c911a8c75c8d3ac722e227fb95354e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_variable_definition.html">VariableDefinition</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#a93c911a8c75c8d3ac722e227fb95354e">GetVariableDefinition</a> (TVariable varId)</td></tr>
<tr class="memdesc:a93c911a8c75c8d3ac722e227fb95354e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the definition of the given injection variable, that has been registered with the <a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#a419370074a281efc1ead6d988da539eb" title="Constructor. The constructor of the Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt; class chec...">Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt;</a>, if any.  <a href="#a93c911a8c75c8d3ac722e227fb95354e">More...</a><br /></td></tr>
<tr class="separator:a93c911a8c75c8d3ac722e227fb95354e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab138632896b07845109f7b7265ba22f0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#ab138632896b07845109f7b7265ba22f0">ClearCodeCaveDefinition</a> (TCodeCave caveId)</td></tr>
<tr class="separator:ab138632896b07845109f7b7265ba22f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49689b1fb48abf819e9ca40ac4d05a9e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#a49689b1fb48abf819e9ca40ac4d05a9e">ClearVariableDefinition</a> (TVariable varId)</td></tr>
<tr class="separator:a49689b1fb48abf819e9ca40ac4d05a9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2520024d77018e97460bb4b4c59f51cb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#a2520024d77018e97460bb4b4c59f51cb">ClearAllCodeCaveDefinitions</a> ()</td></tr>
<tr class="separator:a2520024d77018e97460bb4b4c59f51cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84ca9d9099629d6eaf0ca7f9f44056e3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#a84ca9d9099629d6eaf0ca7f9f44056e3">ClearAllVariableDefinitions</a> ()</td></tr>
<tr class="separator:a84ca9d9099629d6eaf0ca7f9f44056e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a5bb939fd255297a36fd23c630ca75672"><td class="memItemLeft" align="right" valign="top">static byte []&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#a5bb939fd255297a36fd23c630ca75672">GetX86BranchInstructionBytes</a> (<a class="el" href="namespace_r_a_mvader.html#a9e2b14ce7eb13c552fd5175e8b3d7d44">EX86BranchInstructionType</a> instructionType, <a class="el" href="class_r_a_mvader_1_1_memory_address.html">MemoryAddress</a> branchInstructionAddress, <a class="el" href="class_r_a_mvader_1_1_memory_address.html">MemoryAddress</a> targetInstructionAddress, int instructionSize=X86Constants.INSTRUCTION_SIZE_ANY)</td></tr>
<tr class="memdesc:a5bb939fd255297a36fd23c630ca75672"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility method for retrieving a sequence of bytes which represent the machine-level opcode corresponding to a x86 branch instruction, such as CALL, JMP, or a JCC ("conditional jump") instruction.  <a href="#a5bb939fd255297a36fd23c630ca75672">More...</a><br /></td></tr>
<tr class="separator:a5bb939fd255297a36fd23c630ca75672"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="properties"></a>
Properties</h2></td></tr>
<tr class="memitem:ae7d09d9fac03e14b00aa5defd20c843f"><td class="memItemLeft" align="right" valign="top">IntPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#ae7d09d9fac03e14b00aa5defd20c843f">BaseInjectionAddress</a><code> [get]</code></td></tr>
<tr class="memdesc:ae7d09d9fac03e14b00aa5defd20c843f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Keeps the base address of the memory which was allocated for the target process. Backed by the m_baseInjectionAddress field.  <a href="#ae7d09d9fac03e14b00aa5defd20c843f">More...</a><br /></td></tr>
<tr class="separator:ae7d09d9fac03e14b00aa5defd20c843f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed5e8725ccedc94fc5a35970ccbfc988"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#aed5e8725ccedc94fc5a35970ccbfc988">IsInjected</a><code> [get]</code></td></tr>
<tr class="memdesc:aed5e8725ccedc94fc5a35970ccbfc988"><td class="mdescLeft">&#160;</td><td class="mdescRight">A flag that is set to true whenever the <a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#a96b48ff9f2c0bb415c94810299982159" title="Allocates memory into the target process&#39; memory space and injects the code caves and variables into ...">Inject()</a> (or <a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#a75bba917eadc2711528f672d7cd536bf">Inject(MemoryAddress)</a>) method is called and succeeds, and set to false whenever the<a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#ae718ee1ec135b8b74709770d87829bef" title="Resets the internal data of the Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt; regarding the ...">ResetAllocatedMemoryData</a> gets called.  <a href="#aed5e8725ccedc94fc5a35970ccbfc988">More...</a><br /></td></tr>
<tr class="separator:aed5e8725ccedc94fc5a35970ccbfc988"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ac3521ce1d4882d8ea0649d7829243f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_r_a_mvader_1_1_target.html">Target</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#a4ac3521ce1d4882d8ea0649d7829243f">TargetProcess</a><code> [get]</code></td></tr>
<tr class="memdesc:a4ac3521ce1d4882d8ea0649d7829243f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The object used to attach to the target process, so that the <a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#a419370074a281efc1ead6d988da539eb" title="Constructor. The constructor of the Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt; class chec...">Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt;</a> can perform I/O operations into the target process' memory. Backed by the m_targetProcess field.  <a href="#a4ac3521ce1d4882d8ea0649d7829243f">More...</a><br /></td></tr>
<tr class="separator:a4ac3521ce1d4882d8ea0649d7829243f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c44b0feaf095b0e55d80f91ce855ab8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#a2c44b0feaf095b0e55d80f91ce855ab8">RequiredBytesCount</a><code> [get]</code></td></tr>
<tr class="memdesc:a2c44b0feaf095b0e55d80f91ce855ab8"><td class="mdescLeft">&#160;</td><td class="mdescRight">The total number of required bytes to inject the code caves and variables into the target process' memory space, as calculated by a call to the method <a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#afca31c63dacc7873439b66908ef84714" title="Calculates the total number of required bytes to inject the code caves and variables into the target ...">CalculateRequiredBytesCount</a>.  <a href="#a2c44b0feaf095b0e55d80f91ce855ab8">More...</a><br /></td></tr>
<tr class="separator:a2c44b0feaf095b0e55d80f91ce855ab8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b497abbdbc0e3567606c798a039edfd"><td class="memItemLeft" align="right" valign="top">NestedPropertyIndexerCodeCaveOffset&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#a3b497abbdbc0e3567606c798a039edfd">CodeCaveOffset</a><code> [get]</code></td></tr>
<tr class="memdesc:a3b497abbdbc0e3567606c798a039edfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indexer property used to access the code cave offsets, usually for WPF Binding purposes. Calls <a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#afbe434daacbcc5f9f2199c55310bd3fc" title="Retrieves the offset of a given code cave, relative to the base injection address into the target pro...">Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt;.GetCodeCaveOffset(TCodeCave)</a> internally. Backed by the m_codeCaveOffset field.  <a href="#a3b497abbdbc0e3567606c798a039edfd">More...</a><br /></td></tr>
<tr class="separator:a3b497abbdbc0e3567606c798a039edfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a275c4239fa61eb51341ba4484a43ce50"><td class="memItemLeft" align="right" valign="top">NestedPropertyIndexerInjectedCodeCaveAddress&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#a275c4239fa61eb51341ba4484a43ce50">InjectedCodeCaveAddress</a><code> [get]</code></td></tr>
<tr class="memdesc:a275c4239fa61eb51341ba4484a43ce50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indexer property used to access the address where a code cave has been injected, usually for WPF Binding purposes. Calls <a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#a9467a81ecc9e38bc95abe2dd42ebd767" title="Retrieves the address of an injected code cave. This method should only be called after a base inject...">Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt;.GetInjectedCodeCaveAddress(TCodeCave)</a> internally. Backed by the m_injectedCodeCaveAddress field.  <a href="#a275c4239fa61eb51341ba4484a43ce50">More...</a><br /></td></tr>
<tr class="separator:a275c4239fa61eb51341ba4484a43ce50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad57b0685d0e4c07c44f1f064a968192d"><td class="memItemLeft" align="right" valign="top">NestedPropertyIndexerVariableOffset&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#ad57b0685d0e4c07c44f1f064a968192d">VariableOffset</a><code> [get]</code></td></tr>
<tr class="memdesc:ad57b0685d0e4c07c44f1f064a968192d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indexer property used to access variable offsets, usually for WPF Binding purposes. Calls <a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#a6ac14f4ef2ba785e139cf4f937b3b000" title="Retrieves the offset of a given variable, relative to the base injection address into the target proc...">Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt;.GetVariableOffset(TVariable)</a> internally. Backed by the m_variableOffset field.  <a href="#ad57b0685d0e4c07c44f1f064a968192d">More...</a><br /></td></tr>
<tr class="separator:ad57b0685d0e4c07c44f1f064a968192d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab816b37f7a2bddc066a7934c05639138"><td class="memItemLeft" align="right" valign="top">NestedPropertyIndexerInjectedVariableAddress&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#ab816b37f7a2bddc066a7934c05639138">InjectedVariableAddress</a><code> [get]</code></td></tr>
<tr class="memdesc:ab816b37f7a2bddc066a7934c05639138"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indexer property used to access the address where a variable has been injected, usually for WPF Binding purposes. Calls <a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#a0de69746ab2fe19093d38aacd01bdada" title="Retrieves the address of an injected variable. This method should only be called after a base injecti...">Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt;.GetInjectedVariableAddress(TVariable)</a> internally. Backed by the m_injectedVariableAddress field.  <a href="#ab816b37f7a2bddc066a7934c05639138">More...</a><br /></td></tr>
<tr class="separator:ab816b37f7a2bddc066a7934c05639138"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a652d205141e1d13f17c75b3bef8d4604"><td class="memItemLeft" align="right" valign="top">NestedPropertyIndexerVariableSize&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#a652d205141e1d13f17c75b3bef8d4604">VariableSize</a><code> [get]</code></td></tr>
<tr class="memdesc:a652d205141e1d13f17c75b3bef8d4604"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indexer property used to retrieve the size of a variable, usually for WPF Binding purposes. Calls <a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#a851b55538b48bb2292b2a4553fffd313" title="Retrieves the size of a given injection variable.">Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt;.GetVariableSize(TVariable)</a> internally. Backed by the m_variableSize field.  <a href="#a652d205141e1d13f17c75b3bef8d4604">More...</a><br /></td></tr>
<tr class="separator:a652d205141e1d13f17c75b3bef8d4604"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_methods_class_r_a_mvader_1_1_notify_property_changed_adapter"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_class_r_a_mvader_1_1_notify_property_changed_adapter')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="class_r_a_mvader_1_1_notify_property_changed_adapter.html">RAMvader.NotifyPropertyChangedAdapter</a></td></tr>
<tr class="memitem:a8bfa40f312ba2de1d1bd7beee795f25b inherit pro_methods_class_r_a_mvader_1_1_notify_property_changed_adapter"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_a_mvader_1_1_notify_property_changed_adapter.html#a8bfa40f312ba2de1d1bd7beee795f25b">SendPropertyChangedNotification</a> ([CallerMemberName] string propertyName=&quot;&quot;)</td></tr>
<tr class="memdesc:a8bfa40f312ba2de1d1bd7beee795f25b inherit pro_methods_class_r_a_mvader_1_1_notify_property_changed_adapter"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method should be called inside PROPERTY SETTER METHODS to notify listeners of the "property changed" event that the property has been updated.  <a href="class_r_a_mvader_1_1_notify_property_changed_adapter.html#a8bfa40f312ba2de1d1bd7beee795f25b">More...</a><br /></td></tr>
<tr class="separator:a8bfa40f312ba2de1d1bd7beee795f25b inherit pro_methods_class_r_a_mvader_1_1_notify_property_changed_adapter"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header events_class_r_a_mvader_1_1_notify_property_changed_adapter"><td colspan="2" onclick="javascript:toggleInherit('events_class_r_a_mvader_1_1_notify_property_changed_adapter')"><img src="closed.png" alt="-"/>&#160;Events inherited from <a class="el" href="class_r_a_mvader_1_1_notify_property_changed_adapter.html">RAMvader.NotifyPropertyChangedAdapter</a></td></tr>
<tr class="memitem:a0cff0761fe3a42a221ee3337788c4fbf inherit events_class_r_a_mvader_1_1_notify_property_changed_adapter"><td class="memItemLeft" align="right" valign="top">PropertyChangedEventHandler&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_a_mvader_1_1_notify_property_changed_adapter.html#a0cff0761fe3a42a221ee3337788c4fbf">PropertyChanged</a></td></tr>
<tr class="memdesc:a0cff0761fe3a42a221ee3337788c4fbf inherit events_class_r_a_mvader_1_1_notify_property_changed_adapter"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used for implementing the INotifyPropertyChanged interface. <a href="class_r_a_mvader_1_1_notify_property_changed_adapter.html#a0cff0761fe3a42a221ee3337788c4fbf">More...</a><br /></td></tr>
<tr class="separator:a0cff0761fe3a42a221ee3337788c4fbf inherit events_class_r_a_mvader_1_1_notify_property_changed_adapter"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Implements the logic behind the injection of code caves and variables into a target process' memory space. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TMemoryAlterationSetID</td><td>An enumerated type which specifies the identifiers for Memory Alteration Sets that can be enabled or disabled into the target process' memory space. </td></tr>
    <tr><td class="paramname">TCodeCave</td><td>An enumerated type which specifies the identifiers for code caves.</td></tr>
    <tr><td class="paramname">TVariable</td><td>An enumerated type which specifies the identifiers for variables to be injected at the target process. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a419370074a281efc1ead6d988da539eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a419370074a281efc1ead6d988da539eb">&#9670;&nbsp;</a></span>Injector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html">RAMvader.CodeInjection.Injector</a>&lt; TMemoryAlterationSetID, TCodeCave, TVariable &gt;.<a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html">Injector</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor. The constructor of the <a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#a419370074a281efc1ead6d988da539eb" title="Constructor. The constructor of the Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt; class chec...">Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt;</a> class checks the code caves and variables for consistency, throwing an exception if there is any error found. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_r_a_mvader_1_1_unsupported_data_type_exception.html" title="An exception which is thrown when the user tries to perform a read or write operation using a data ty...">UnsupportedDataTypeException</a></td><td>Thrown if any of the injection variables (enumerators of the type <em>TVariable</em> ) has a data type that is not supported by the <a class="el" href="namespace_r_a_mvader.html">RAMvader</a> library. </td></tr>
    <tr><td class="paramname"><a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector_generic_parameters_exception.html" title="Exception thrown when trying to instantiate an Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt; whose generic parameters are illegal for some reason. All Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt;&#39;s generic parameters should be enumerations. ">InjectorGenericParametersException</a></td><td>Thrown in cases where there are any errors with the generic types defined for the <a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#a419370074a281efc1ead6d988da539eb" title="Constructor. The constructor of the Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt; class chec...">Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt;</a>. The types <em>TMemoryAlterationSetID</em> , <em>TCodeCave</em>  and <em>TVariable</em>  MUST be enumerations. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a7afd16f94510d4786682161612718889"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7afd16f94510d4786682161612718889">&#9670;&nbsp;</a></span>AddMemoryAlteration()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html">RAMvader.CodeInjection.Injector</a>&lt; TMemoryAlterationSetID, TCodeCave, TVariable &gt;.AddMemoryAlteration </td>
          <td>(</td>
          <td class="paramtype">TMemoryAlterationSetID&#160;</td>
          <td class="paramname"><em>memoryAlterationSetID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_memory_alteration_base.html">MemoryAlterationBase</a>&#160;</td>
          <td class="paramname"><em>memoryAlteration</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a memory alteration to the set of alterations related to a given identifier. Memory alteration sets are kept in as list, and this method adds a memory alteration to the end of this list. The elements of a set of memory alterations are enabled/disabled in the order they get added to the list. You can then call <a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#a424976a64ff18332548d98c4fc603f74" title="Activates or deactivates all the memory alterations registered for a given memory alterations set...">SetMemoryAlterationsActive(TMemoryAlterationSetID, bool)</a> to enable or disable the whole set of alterations related to an identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">memoryAlterationSetID</td><td>The identifier that identifies the set of alterations that can be enabled/disabled all at once.</td></tr>
    <tr><td class="paramname">memoryAlteration</td><td>An object representing the memory alteration that should be added to the given set.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afca31c63dacc7873439b66908ef84714"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afca31c63dacc7873439b66908ef84714">&#9670;&nbsp;</a></span>CalculateRequiredBytesCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html">RAMvader.CodeInjection.Injector</a>&lt; TMemoryAlterationSetID, TCodeCave, TVariable &gt;.CalculateRequiredBytesCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the total number of required bytes to inject the code caves and variables into the target process' memory space. This calculation takes in consideration the separation bytes between two consecutive code caves, the separation between the code caves section and the variables section and the size of each one of the injection variables. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the number of bytes required to Inject into the target process' memory.</dd></dl>

</div>
</div>
<a id="a2520024d77018e97460bb4b4c59f51cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2520024d77018e97460bb4b4c59f51cb">&#9670;&nbsp;</a></span>ClearAllCodeCaveDefinitions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html">RAMvader.CodeInjection.Injector</a>&lt; TMemoryAlterationSetID, TCodeCave, TVariable &gt;.ClearAllCodeCaveDefinitions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Clears the definition of all code caves, effectively making all of them "undefined" for the <a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#a419370074a281efc1ead6d988da539eb" title="Constructor. The constructor of the Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt; class chec...">Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt;</a>. </p>
<p>Calling this will prevent the code caves from being injected in the target process' memory space - as their definition will be voided - until they get redefined/updated. </p>
<p>Currently, the definitions of code caves and injection variables can only be updated when the <a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#a419370074a281efc1ead6d988da539eb" title="Constructor. The constructor of the Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt; class chec...">Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt;</a> is in the "not injected" state. </p>

</div>
</div>
<a id="a84ca9d9099629d6eaf0ca7f9f44056e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84ca9d9099629d6eaf0ca7f9f44056e3">&#9670;&nbsp;</a></span>ClearAllVariableDefinitions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html">RAMvader.CodeInjection.Injector</a>&lt; TMemoryAlterationSetID, TCodeCave, TVariable &gt;.ClearAllVariableDefinitions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Clears the definition of all injection varibles, effectively making all of them "undefined" for the <a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#a419370074a281efc1ead6d988da539eb" title="Constructor. The constructor of the Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt; class chec...">Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt;</a>. </p>
<p>Calling this will prevent the injection variables from being injected in the target process' memory space - as their definition will be voided - until they get redefined/updated. </p>
<p>Currently, the definitions of code caves and injection variables can only be updated when the <a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#a419370074a281efc1ead6d988da539eb" title="Constructor. The constructor of the Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt; class chec...">Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt;</a> is in the "not injected" state. </p>

</div>
</div>
<a id="ab138632896b07845109f7b7265ba22f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab138632896b07845109f7b7265ba22f0">&#9670;&nbsp;</a></span>ClearCodeCaveDefinition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html">RAMvader.CodeInjection.Injector</a>&lt; TMemoryAlterationSetID, TCodeCave, TVariable &gt;.ClearCodeCaveDefinition </td>
          <td>(</td>
          <td class="paramtype">TCodeCave&#160;</td>
          <td class="paramname"><em>caveId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Clears the definition of a specific code cave, effectively making it "undefined" for the <a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#a419370074a281efc1ead6d988da539eb" title="Constructor. The constructor of the Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt; class chec...">Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt;</a>. </p>
<p>Calling this will prevent the code cave from being injected in the target process' memory space - as its definition will be voided - until it gets redefined/updated. </p>
<p>Currently, the definitions of code caves and injection variables can only be updated when the <a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#a419370074a281efc1ead6d988da539eb" title="Constructor. The constructor of the Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt; class chec...">Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt;</a> is in the "not injected" state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">caveId</td><td>The code cave whose definition will be cleared.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a flag specifying if the definition has been found and removed.</dd></dl>

</div>
</div>
<a id="a49689b1fb48abf819e9ca40ac4d05a9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49689b1fb48abf819e9ca40ac4d05a9e">&#9670;&nbsp;</a></span>ClearVariableDefinition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html">RAMvader.CodeInjection.Injector</a>&lt; TMemoryAlterationSetID, TCodeCave, TVariable &gt;.ClearVariableDefinition </td>
          <td>(</td>
          <td class="paramtype">TVariable&#160;</td>
          <td class="paramname"><em>varId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Clears the definition of a specific injection variable, effectively making it "undefined" for the <a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#a419370074a281efc1ead6d988da539eb" title="Constructor. The constructor of the Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt; class chec...">Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt;</a>. </p>
<p>Calling this will prevent the injection variable from being injected in the target process' memory space - as its definition will be voided - until it gets redefined/updated. </p>
<p>Currently, the definitions of code caves and injection variables can only be updated when the <a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#a419370074a281efc1ead6d988da539eb" title="Constructor. The constructor of the Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt; class chec...">Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt;</a> is in the "not injected" state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">varId</td><td>The injection variable whose definition will be cleared.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a flag specifying if the definition has been found and removed.</dd></dl>

</div>
</div>
<a id="aa7841dd7b14a8cbb993633712b968799"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7841dd7b14a8cbb993633712b968799">&#9670;&nbsp;</a></span>GetBaseInjectionAddress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IntPtr <a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html">RAMvader.CodeInjection.Injector</a>&lt; TMemoryAlterationSetID, TCodeCave, TVariable &gt;.GetBaseInjectionAddress </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the address where the <a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#a419370074a281efc1ead6d988da539eb" title="Constructor. The constructor of the Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt; class chec...">Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt;</a> has injected its data on the target process.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns the base address where the injection has been performed. If the <a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#a419370074a281efc1ead6d988da539eb" title="Constructor. The constructor of the Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt; class chec...">Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt;</a> didn't perform the injection yet, the return value is IntPtr.Zero. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#a96b48ff9f2c0bb415c94810299982159" title="Allocates memory into the target process&#39; memory space and injects the code caves and variables into ...">Inject()</a>, <a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#a75bba917eadc2711528f672d7cd536bf">Inject(MemoryAddress)</a></dd></dl>

</div>
</div>
<a id="a3c62aeb3187547262ccb76672bbc4927"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c62aeb3187547262ccb76672bbc4927">&#9670;&nbsp;</a></span>GetCodeCaveDefinition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_code_cave_definition.html">CodeCaveDefinition</a>&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt; <a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html">RAMvader.CodeInjection.Injector</a>&lt; TMemoryAlterationSetID, TCodeCave, TVariable &gt;.GetCodeCaveDefinition </td>
          <td>(</td>
          <td class="paramtype">TCodeCave&#160;</td>
          <td class="paramname"><em>caveId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the definition of the given code cave, that has been registered with the <a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#a419370074a281efc1ead6d988da539eb" title="Constructor. The constructor of the Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt; class chec...">Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt;</a>, if any. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">caveId</td><td>The identifier of the code cave whose definition is to be retrieved.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>In case of success, returns the CodeCaveDefinition&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt; object representing the definition that has been registered for the given code cave. </dd></dl>
<p>In case of failure, returns </p><div class="fragment"><div class="line">null</div></div><!-- fragment --><p>.</p>

</div>
</div>
<a id="afbe434daacbcc5f9f2199c55310bd3fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbe434daacbcc5f9f2199c55310bd3fc">&#9670;&nbsp;</a></span>GetCodeCaveOffset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html">RAMvader.CodeInjection.Injector</a>&lt; TMemoryAlterationSetID, TCodeCave, TVariable &gt;.GetCodeCaveOffset </td>
          <td>(</td>
          <td class="paramtype">TCodeCave&#160;</td>
          <td class="paramname"><em>codeCaveID</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the offset of a given code cave, relative to the base injection address into the target process' memory space.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">codeCaveID</td><td>The identifier of the code cave.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the offset of the given code cave.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injection_artifact_not_found_exception.html" title="Exception thrown whenever an operation fails to find an injection artifact (which includes injection ...">InjectionArtifactNotFoundException</a></td><td>Thrown when the artifact (injection variable or code cave) could not be found by the method.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab126ed7ad623179815ee82e0b8a3a71b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab126ed7ad623179815ee82e0b8a3a71b">&#9670;&nbsp;</a></span>GetCodeCavesSeparationBytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">byte [] <a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html">RAMvader.CodeInjection.Injector</a>&lt; TMemoryAlterationSetID, TCodeCave, TVariable &gt;.GetCodeCavesSeparationBytes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the sequence of bytes used to separate two consecutive code caves.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns the sequence of bytes used to separate two consecutive code caves in memory.</dd></dl>

</div>
</div>
<a id="a529713eb9304f7733060269ca4aa663a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a529713eb9304f7733060269ca4aa663a">&#9670;&nbsp;</a></span>GetCurrentInjectionAddress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IntPtr <a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html">RAMvader.CodeInjection.Injector</a>&lt; TMemoryAlterationSetID, TCodeCave, TVariable &gt;.GetCurrentInjectionAddress </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Called during the injection procedure to retrieve the address right after the last byte generated by the <a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#a419370074a281efc1ead6d988da539eb" title="Constructor. The constructor of the Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt; class chec...">Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt;</a> instance. This method is called by lower APIs which need to use the current injection position, mainly to generate branching instructions. </p>
<p>The return value of this method is effectivelly the sum of <a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#ae7d09d9fac03e14b00aa5defd20c843f" title="Keeps the base address of the memory which was allocated for the target process. Backed by the m_base...">BaseInjectionAddress</a> with the return value of the <a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#a188e8fc2fe061ad60898feeb1de21831" title="Called during the injection procedure to retrieve the number of bytes already generated by the Inject...">GetCurrentInjectionOffset</a> method. </p>
<dl class="section return"><dt>Returns</dt><dd>The return value of this method is effectivelly the sum of <a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#ae7d09d9fac03e14b00aa5defd20c843f" title="Keeps the base address of the memory which was allocated for the target process. Backed by the m_base...">BaseInjectionAddress</a> with the return value of the <a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#a188e8fc2fe061ad60898feeb1de21831" title="Called during the injection procedure to retrieve the number of bytes already generated by the Inject...">GetCurrentInjectionOffset</a> method. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#a529713eb9304f7733060269ca4aa663a">GetCurrentInjectionAddress</a></dd></dl>

</div>
</div>
<a id="a188e8fc2fe061ad60898feeb1de21831"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a188e8fc2fe061ad60898feeb1de21831">&#9670;&nbsp;</a></span>GetCurrentInjectionOffset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html">RAMvader.CodeInjection.Injector</a>&lt; TMemoryAlterationSetID, TCodeCave, TVariable &gt;.GetCurrentInjectionOffset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called during the injection procedure to retrieve the number of bytes already generated by the <a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#a419370074a281efc1ead6d988da539eb" title="Constructor. The constructor of the Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt; class chec...">Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt;</a> instance. This method is called by lower APIs which need to use the current injection position, mainly to generate branching instructions (which need to know their exact address when they need to be generated). </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the number of bytes that have already been generated by the <a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#a419370074a281efc1ead6d988da539eb" title="Constructor. The constructor of the Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt; class chec...">Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt;</a> during an injection procedure. </dd></dl>
<p>If the injection procedure hasn't started yet, or the <a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#a419370074a281efc1ead6d988da539eb" title="Constructor. The constructor of the Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt; class chec...">Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt;</a> finds itself in "not injected" state, the return value is zero. </p>
<p>If this method is called after a successful injection procedure, the return value is the total number of injected bytes (which is effectivelly the same result of calling <a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#afca31c63dacc7873439b66908ef84714" title="Calculates the total number of required bytes to inject the code caves and variables into the target ...">CalculateRequiredBytesCount</a>). </p>
<p>If this method is called during the injection procedure (which is usually done when processing CodeCaveArtifact&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt; objects that compose the code caves to be injected), the return value is the total number of bytes that have been injected so far by the <a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#a419370074a281efc1ead6d988da539eb" title="Constructor. The constructor of the Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt; class chec...">Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt;</a>. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#a529713eb9304f7733060269ca4aa663a">GetCurrentInjectionAddress</a></dd></dl>

</div>
</div>
<a id="a9467a81ecc9e38bc95abe2dd42ebd767"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9467a81ecc9e38bc95abe2dd42ebd767">&#9670;&nbsp;</a></span>GetInjectedCodeCaveAddress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_r_a_mvader_1_1_absolute_memory_address.html">AbsoluteMemoryAddress</a> <a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html">RAMvader.CodeInjection.Injector</a>&lt; TMemoryAlterationSetID, TCodeCave, TVariable &gt;.GetInjectedCodeCaveAddress </td>
          <td>(</td>
          <td class="paramtype">TCodeCave&#160;</td>
          <td class="paramname"><em>codeCaveID</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the address of an injected code cave. This method should only be called after a base injection address has been defined for the <a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#a419370074a281efc1ead6d988da539eb" title="Constructor. The constructor of the Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt; class chec...">Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt;</a> to Inject code caves and variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">codeCaveID</td><td>The identifier of the target code cave.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the address of the given code cave, into the target process' memory space.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injection_artifact_not_found_exception.html" title="Exception thrown whenever an operation fails to find an injection artifact (which includes injection ...">InjectionArtifactNotFoundException</a></td><td>Thrown when the artifact (injection variable or code cave) could not be found by the method.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8c66ac1bd59455147dc47caf6f69c895"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c66ac1bd59455147dc47caf6f69c895">&#9670;&nbsp;</a></span>GetInjectedCodeCaveAddressAsBytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">byte [] <a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html">RAMvader.CodeInjection.Injector</a>&lt; TMemoryAlterationSetID, TCodeCave, TVariable &gt;.GetInjectedCodeCaveAddressAsBytes </td>
          <td>(</td>
          <td class="paramtype">TCodeCave&#160;</td>
          <td class="paramname"><em>codeCaveID</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the address of an injected code cave, represented as bytes stored in the target process' memory space.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">codeCaveID</td><td>The identifier of the target code cave.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the array of bytes representing the address of the injected code cave, as it is to be stored into the target process' memory space. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">NullReferenceException</td><td>Thrown when the <a class="el" href="class_r_a_mvader_1_1_target.html" title="RAMvader library&#39;s core class. Instances of this class are able to &quot;attach&quot; to processes and execute ...">Target</a> associated with the <a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#a419370074a281efc1ead6d988da539eb" title="Constructor. The constructor of the Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt; class chec...">Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt;</a> hasn't been set. A <a class="el" href="class_r_a_mvader_1_1_target.html" title="RAMvader library&#39;s core class. Instances of this class are able to &quot;attach&quot; to processes and execute ...">Target</a> instance can be associated to an <a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#a419370074a281efc1ead6d988da539eb" title="Constructor. The constructor of the Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt; class chec...">Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt;</a> by calling the method <a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#ad901aa5384b7e4f5c87362003c432e6f" title="Initializes or modifies the reference to the object used by the Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt; to perform write operations to the target process&#39; memory. The Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt; also uses this object to know the endianness and pointer size of the target process. ">Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt;.SetTargetProcess(Target)</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0de69746ab2fe19093d38aacd01bdada"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0de69746ab2fe19093d38aacd01bdada">&#9670;&nbsp;</a></span>GetInjectedVariableAddress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_r_a_mvader_1_1_absolute_memory_address.html">AbsoluteMemoryAddress</a> <a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html">RAMvader.CodeInjection.Injector</a>&lt; TMemoryAlterationSetID, TCodeCave, TVariable &gt;.GetInjectedVariableAddress </td>
          <td>(</td>
          <td class="paramtype">TVariable&#160;</td>
          <td class="paramname"><em>varID</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the address of an injected variable. This method should only be called after a base injection address has been defined for the <a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#a419370074a281efc1ead6d988da539eb" title="Constructor. The constructor of the Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt; class chec...">Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt;</a> to Inject code caves and variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">varID</td><td>The identifier of the target variable.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the address of the given variable, into the target process' memory space.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injection_artifact_not_found_exception.html" title="Exception thrown whenever an operation fails to find an injection artifact (which includes injection ...">InjectionArtifactNotFoundException</a></td><td>Thrown when the artifact (injection variable or code cave) could not be found by the method.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aeea87db151126ba604fe2e9f5ddd92d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeea87db151126ba604fe2e9f5ddd92d2">&#9670;&nbsp;</a></span>GetInjectedVariableAddressAsBytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">byte [] <a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html">RAMvader.CodeInjection.Injector</a>&lt; TMemoryAlterationSetID, TCodeCave, TVariable &gt;.GetInjectedVariableAddressAsBytes </td>
          <td>(</td>
          <td class="paramtype">TVariable&#160;</td>
          <td class="paramname"><em>varID</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the address of an injected variable, represented as bytes stored in the target process' memory space.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">varID</td><td>The identifier of the target variable.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the array of bytes representing the address of the injected variable, as it is to be stored into the target process' memory space. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">NullReferenceException</td><td>Thrown when the <a class="el" href="class_r_a_mvader_1_1_target.html" title="RAMvader library&#39;s core class. Instances of this class are able to &quot;attach&quot; to processes and execute ...">Target</a> associated with the <a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#a419370074a281efc1ead6d988da539eb" title="Constructor. The constructor of the Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt; class chec...">Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt;</a> hasn't been set. A <a class="el" href="class_r_a_mvader_1_1_target.html" title="RAMvader library&#39;s core class. Instances of this class are able to &quot;attach&quot; to processes and execute ...">Target</a> instance can be associated to an <a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#a419370074a281efc1ead6d988da539eb" title="Constructor. The constructor of the Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt; class chec...">Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt;</a> by calling the method <a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#ad901aa5384b7e4f5c87362003c432e6f" title="Initializes or modifies the reference to the object used by the Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt; to perform write operations to the target process&#39; memory. The Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt; also uses this object to know the endianness and pointer size of the target process. ">Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt;.SetTargetProcess(Target)</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a39a81acaf6e8604bc4b536b17cef103b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39a81acaf6e8604bc4b536b17cef103b">&#9670;&nbsp;</a></span>GetMemoryAlterations()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IEnumerable&lt;<a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_memory_alteration_base.html">MemoryAlterationBase</a>&gt; <a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html">RAMvader.CodeInjection.Injector</a>&lt; TMemoryAlterationSetID, TCodeCave, TVariable &gt;.GetMemoryAlterations </td>
          <td>(</td>
          <td class="paramtype">TMemoryAlterationSetID&#160;</td>
          <td class="paramname"><em>memoryAlterationSetID</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an enumerable object containing all memory alterations registered for a given memory alteration set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">memoryAlterationSetID</td><td>The identifier that identifies the set of alterations that can be enabled/disabled all at once.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns an enumerable list containing all the memory alterations in the given set.</dd></dl>

</div>
</div>
<a id="a8f3a5f9dbe3bf46fa64c3d856d553b78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f3a5f9dbe3bf46fa64c3d856d553b78">&#9670;&nbsp;</a></span>GetTargetProcess()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_r_a_mvader_1_1_target.html">Target</a> <a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html">RAMvader.CodeInjection.Injector</a>&lt; TMemoryAlterationSetID, TCodeCave, TVariable &gt;.GetTargetProcess </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the current reference to the object used by the <a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#a419370074a281efc1ead6d988da539eb" title="Constructor. The constructor of the Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt; class chec...">Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt;</a> to perform write operations to the target process' memory. The <a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#a419370074a281efc1ead6d988da539eb" title="Constructor. The constructor of the Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt; class chec...">Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt;</a> also uses this object to know the endianness and pointer size of the target process. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the object used for performing memory I/O operations on the target process.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#ad901aa5384b7e4f5c87362003c432e6f" title="Initializes or modifies the reference to the object used by the Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt; to perform write operations to the target process&#39; memory. The Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt; also uses this object to know the endianness and pointer size of the target process. ">SetTargetProcess(Target)</a></dd></dl>

</div>
</div>
<a id="a93c911a8c75c8d3ac722e227fb95354e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93c911a8c75c8d3ac722e227fb95354e">&#9670;&nbsp;</a></span>GetVariableDefinition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_variable_definition.html">VariableDefinition</a> <a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html">RAMvader.CodeInjection.Injector</a>&lt; TMemoryAlterationSetID, TCodeCave, TVariable &gt;.GetVariableDefinition </td>
          <td>(</td>
          <td class="paramtype">TVariable&#160;</td>
          <td class="paramname"><em>varId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the definition of the given injection variable, that has been registered with the <a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#a419370074a281efc1ead6d988da539eb" title="Constructor. The constructor of the Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt; class chec...">Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt;</a>, if any. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">varId</td><td>The identifier of the injection variable whose definition is to be retrieved.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>In case of success, returns the <a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_variable_definition.html" title="Keeps the metadata related to an injection variable.">VariableDefinition</a> object representing the definition that has been registered for the given injection variable. </dd></dl>
<p>In case of failure, returns </p><div class="fragment"><div class="line">null</div></div><!-- fragment --><p>.</p>

</div>
</div>
<a id="a6ac14f4ef2ba785e139cf4f937b3b000"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ac14f4ef2ba785e139cf4f937b3b000">&#9670;&nbsp;</a></span>GetVariableOffset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html">RAMvader.CodeInjection.Injector</a>&lt; TMemoryAlterationSetID, TCodeCave, TVariable &gt;.GetVariableOffset </td>
          <td>(</td>
          <td class="paramtype">TVariable&#160;</td>
          <td class="paramname"><em>varID</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the offset of a given variable, relative to the base injection address into the target process' memory space.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">varID</td><td>The identifier of the variable whose offset is to be retrieved.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the offset to given variable.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injection_artifact_not_found_exception.html" title="Exception thrown whenever an operation fails to find an injection artifact (which includes injection ...">InjectionArtifactNotFoundException</a></td><td>Thrown when the artifact (injection variable or code cave) could not be found by the method.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a851b55538b48bb2292b2a4553fffd313"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a851b55538b48bb2292b2a4553fffd313">&#9670;&nbsp;</a></span>GetVariableSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html">RAMvader.CodeInjection.Injector</a>&lt; TMemoryAlterationSetID, TCodeCave, TVariable &gt;.GetVariableSize </td>
          <td>(</td>
          <td class="paramtype">TVariable&#160;</td>
          <td class="paramname"><em>varID</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the size of a given injection variable.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">varID</td><td>The identifier of the variable whose size is to be retrieved.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the size of the given injection variable, given in bytes. If the variable has no definition set for it, the returned size is ZERO. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">NullReferenceException</td><td>Thrown when the <a class="el" href="class_r_a_mvader_1_1_target.html" title="RAMvader library&#39;s core class. Instances of this class are able to &quot;attach&quot; to processes and execute ...">Target</a> associated with the <a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#a419370074a281efc1ead6d988da539eb" title="Constructor. The constructor of the Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt; class chec...">Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt;</a> hasn't been set. A <a class="el" href="class_r_a_mvader_1_1_target.html" title="RAMvader library&#39;s core class. Instances of this class are able to &quot;attach&quot; to processes and execute ...">Target</a> instance can be associated to an <a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#a419370074a281efc1ead6d988da539eb" title="Constructor. The constructor of the Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt; class chec...">Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt;</a> by calling the method <a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#ad901aa5384b7e4f5c87362003c432e6f" title="Initializes or modifies the reference to the object used by the Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt; to perform write operations to the target process&#39; memory. The Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt; also uses this object to know the endianness and pointer size of the target process. ">Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt;.SetTargetProcess(Target)</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af8b26ea98ec4cf0c8fc5755a81467150"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8b26ea98ec4cf0c8fc5755a81467150">&#9670;&nbsp;</a></span>GetVariablesSectionSeparationBytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">byte [] <a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html">RAMvader.CodeInjection.Injector</a>&lt; TMemoryAlterationSetID, TCodeCave, TVariable &gt;.GetVariablesSectionSeparationBytes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the sequence of bytes used to separate the injected code caves section from the injected variables section.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns the sequence of bytes used to separate two consecutive code caves in memory.</dd></dl>

</div>
</div>
<a id="a5bb939fd255297a36fd23c630ca75672"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bb939fd255297a36fd23c630ca75672">&#9670;&nbsp;</a></span>GetX86BranchInstructionBytes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static byte [] <a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html">RAMvader.CodeInjection.Injector</a>&lt; TMemoryAlterationSetID, TCodeCave, TVariable &gt;.GetX86BranchInstructionBytes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_r_a_mvader.html#a9e2b14ce7eb13c552fd5175e8b3d7d44">EX86BranchInstructionType</a>&#160;</td>
          <td class="paramname"><em>instructionType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_r_a_mvader_1_1_memory_address.html">MemoryAddress</a>&#160;</td>
          <td class="paramname"><em>branchInstructionAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_r_a_mvader_1_1_memory_address.html">MemoryAddress</a>&#160;</td>
          <td class="paramname"><em>targetInstructionAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>instructionSize</em> = <code>X86Constants.INSTRUCTION_SIZE_ANY</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Utility method for retrieving a sequence of bytes which represent the machine-level opcode corresponding to a x86 branch instruction, such as CALL, JMP, or a JCC ("conditional jump") instruction. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instructionType</td><td>The specific type of branch instruction to be generated.</td></tr>
    <tr><td class="paramname">branchInstructionAddress</td><td>The address where the branch instruction is supposed to be placed in the target process' memory space.</td></tr>
    <tr><td class="paramname">targetInstructionAddress</td><td>The address to where the placed branch instruction will make the target process' execution flow to.</td></tr>
    <tr><td class="paramname">instructionSize</td><td>When replacing an instruction in a target process' memory space by a branch instruction, this parameter specifies the size of the instruction to be replaced. If this size is larger than the size of the branch instruction, the remaining bytes are filled with NOP opcodes in the returned bytes sequence, so that the branch instruction might replace other instructions while keeping the consistency of its surrounding instructions when the flow of code returns from the branch (if that ever happens).</td></tr>
  </table>
  </dd>
</dl>
<p>If the size does not matter, X86Constants.INSTRUCTION_SIZE_ANY can be used. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns a sequence of bytes representing the branch instruction's opcode(s) that compose the given instruction.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_unsupported_instruction_generation_exception.html" title="Exception thrown when the Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt; is unable to generat...">UnsupportedInstructionGenerationException</a></td><td>Thrown when the instruction cannot be generated, because the given instruction type does not exist or has not been implemented.</td></tr>
    <tr><td class="paramname"><a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_illegal_instruction_generation_exception.html" title="Exception thrown when an instruction cannot be generated, because the generated instruction would be ...">IllegalInstructionGenerationException</a></td><td>Thrown when the instruction cannot be generated, because the generated instruction would be illegal somehow.</td></tr>
    <tr><td class="paramname"><a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_instruction_too_large_exception.html" title="Exception thrown when the Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt; tries to generate an...">InstructionTooLargeException</a></td><td>Thrown when the given instruction size is less than the size required to generate the instruction.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a529dd9750b1d40ed71cbed74fd2d1a40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a529dd9750b1d40ed71cbed74fd2d1a40">&#9670;&nbsp;</a></span>IncreaseCurrentInjectionOffset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html">RAMvader.CodeInjection.Injector</a>&lt; TMemoryAlterationSetID, TCodeCave, TVariable &gt;.IncreaseCurrentInjectionOffset </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>increase</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called during the injection procedure to increase the number of bytes already generated by the <a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#a419370074a281efc1ead6d988da539eb" title="Constructor. The constructor of the Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt; class chec...">Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt;</a> instance. This method is called by lower APIs to inform changes which should be made in the current injection position, mainly to allow for the generation branching instructions (which need to know their exact address when they need to be generated). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">increase</td><td>The amount of bytes to increase for the internal count of the injection offset value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#a188e8fc2fe061ad60898feeb1de21831" title="Called during the injection procedure to retrieve the number of bytes already generated by the Inject...">GetCurrentInjectionOffset</a>, <a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#a529713eb9304f7733060269ca4aa663a">GetCurrentInjectionAddress</a></dd></dl>

</div>
</div>
<a id="a96b48ff9f2c0bb415c94810299982159"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96b48ff9f2c0bb415c94810299982159">&#9670;&nbsp;</a></span>Inject() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html">RAMvader.CodeInjection.Injector</a>&lt; TMemoryAlterationSetID, TCodeCave, TVariable &gt;.Inject </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates memory into the target process' memory space and injects the code caves and variables into that allocated memory. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">NullReferenceException</td><td>Thrown when the <a class="el" href="class_r_a_mvader_1_1_target.html" title="RAMvader library&#39;s core class. Instances of this class are able to &quot;attach&quot; to processes and execute ...">Target</a> associated with the <a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#a419370074a281efc1ead6d988da539eb" title="Constructor. The constructor of the Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt; class chec...">Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt;</a> hasn't been set. A <a class="el" href="class_r_a_mvader_1_1_target.html" title="RAMvader library&#39;s core class. Instances of this class are able to &quot;attach&quot; to processes and execute ...">Target</a> instance can be associated to an <a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#a419370074a281efc1ead6d988da539eb" title="Constructor. The constructor of the Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt; class chec...">Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt;</a> by calling the method <a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#ad901aa5384b7e4f5c87362003c432e6f" title="Initializes or modifies the reference to the object used by the Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt; to perform write operations to the target process&#39; memory. The Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt; also uses this object to know the endianness and pointer size of the target process. ">Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt;.SetTargetProcess(Target)</a>. </td></tr>
    <tr><td class="paramname"><a class="el" href="class_r_a_mvader_1_1_instance_not_attached_exception.html" title="Exception thrown when a method that requires the Target instance to be attached is called...">InstanceNotAttachedException</a></td><td>Thrown when the <a class="el" href="class_r_a_mvader_1_1_target.html" title="RAMvader library&#39;s core class. Instances of this class are able to &quot;attach&quot; to processes and execute ...">Target</a> instance has not been attached to a target process before the method is called. </td></tr>
    <tr><td class="paramname"><a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_virtual_memory_allocation_exception.html" title="An exception thrown by the Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt;.Inject() method to indicate that it was unable to allocate virtual memory in the target process&#39; memory space.">VirtualMemoryAllocationException</a></td><td>Thrown when the method cannot allocate virtual memory in the target process' memory space, to inject the data in the target process. Some softwares might implement security schemes that prevent you from allocating virtual memory on them, which in turn might require you to use manual injection of data (see <a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#a75bba917eadc2711528f672d7cd536bf">Inject(MemoryAddress)</a>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#aa7841dd7b14a8cbb993633712b968799" title="Retrieves the address where the Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt; has injected i...">GetBaseInjectionAddress</a></dd></dl>

</div>
</div>
<a id="a75bba917eadc2711528f672d7cd536bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75bba917eadc2711528f672d7cd536bf">&#9670;&nbsp;</a></span>Inject() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html">RAMvader.CodeInjection.Injector</a>&lt; TMemoryAlterationSetID, TCodeCave, TVariable &gt;.Inject </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_r_a_mvader_1_1_memory_address.html">MemoryAddress</a>&#160;</td>
          <td class="paramname"><em>baseInjectionAddress</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Injects the code caves and variables into the target process' memory space. This overloaded version of the <a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#a96b48ff9f2c0bb415c94810299982159" title="Allocates memory into the target process&#39; memory space and injects the code caves and variables into ...">Inject()</a> method can be used to Inject the code caves into a specific point of the target process' memory space. Notice, though, that for the code caves to work correctly, they need to be injected into a memory region with appropriate permissions. Those are usually READ+WRITE+EXECUTE permissions (READ+WRITE for injected variables and EXECUTE for allowing the target process to execute the code caves). If you need to calculate the total number of bytes required by the <a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#a419370074a281efc1ead6d988da539eb" title="Constructor. The constructor of the Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt; class chec...">Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt;</a> to inject the code caves and variables, see <a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#afca31c63dacc7873439b66908ef84714" title="Calculates the total number of required bytes to inject the code caves and variables into the target ...">CalculateRequiredBytesCount</a>. </p>
<p>Notice that you should not use the InjectedCodeCaveMemoryAddress&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt; and InjectedVariableMemoryAddress&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt; classes to specify the injection point for this method, because for these classes to solve the right base address, they would require a previous injection to have happened already. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseInjectionAddress</td><td>The address - into the target process' memory space - where the <a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#a419370074a281efc1ead6d988da539eb" title="Constructor. The constructor of the Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt; class chec...">Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt;</a> will Inject the code caves and variables. A value of "IntPtr.Zero" will cause the method to exit without any effect on the target process' memory space. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">NullReferenceException</td><td>Thrown when the <a class="el" href="class_r_a_mvader_1_1_target.html" title="RAMvader library&#39;s core class. Instances of this class are able to &quot;attach&quot; to processes and execute ...">Target</a> associated with the <a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#a419370074a281efc1ead6d988da539eb" title="Constructor. The constructor of the Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt; class chec...">Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt;</a> hasn't been set. A <a class="el" href="class_r_a_mvader_1_1_target.html" title="RAMvader library&#39;s core class. Instances of this class are able to &quot;attach&quot; to processes and execute ...">Target</a> instance can be associated to an <a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#a419370074a281efc1ead6d988da539eb" title="Constructor. The constructor of the Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt; class chec...">Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt;</a> by calling the method <a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#ad901aa5384b7e4f5c87362003c432e6f" title="Initializes or modifies the reference to the object used by the Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt; to perform write operations to the target process&#39; memory. The Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt; also uses this object to know the endianness and pointer size of the target process. ">Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt;.SetTargetProcess(Target)</a>. </td></tr>
    <tr><td class="paramname"><a class="el" href="class_r_a_mvader_1_1_instance_not_attached_exception.html" title="Exception thrown when a method that requires the Target instance to be attached is called...">InstanceNotAttachedException</a></td><td>Thrown when the <a class="el" href="class_r_a_mvader_1_1_target.html" title="RAMvader library&#39;s core class. Instances of this class are able to &quot;attach&quot; to processes and execute ...">Target</a> instance has not been attached to a target process before the method is called. </td></tr>
    <tr><td class="paramname"><a class="el" href="class_r_a_mvader_1_1_required_write_exception.html" title="Exception that is thrown when an output/write operation that was required to succeed returns a fail s...">RequiredWriteException</a></td><td>Thrown when the <a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#a419370074a281efc1ead6d988da539eb" title="Constructor. The constructor of the Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt; class chec...">Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt;</a> fails to write the injection data in the target process' memory space. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#aa7841dd7b14a8cbb993633712b968799" title="Retrieves the address where the Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt; has injected i...">GetBaseInjectionAddress</a></dd></dl>

</div>
</div>
<a id="a6fe29aeeff7b94a0d0898296cd5f80d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fe29aeeff7b94a0d0898296cd5f80d1">&#9670;&nbsp;</a></span>IsCodeCaveInjected()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html">RAMvader.CodeInjection.Injector</a>&lt; TMemoryAlterationSetID, TCodeCave, TVariable &gt;.IsCodeCaveInjected </td>
          <td>(</td>
          <td class="paramtype">TCodeCave&#160;</td>
          <td class="paramname"><em>caveID</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verifies if a given code cave has been injected by the <a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#a419370074a281efc1ead6d988da539eb" title="Constructor. The constructor of the Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt; class chec...">Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt;</a> on the target process' memory space. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">caveID</td><td>The code cave whose injection needs to be verified.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If the <a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#a419370074a281efc1ead6d988da539eb" title="Constructor. The constructor of the Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt; class chec...">Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt;</a> hasn't performed the injection procedure yet, or if its associated <a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#a4ac3521ce1d4882d8ea0649d7829243f" title="The object used to attach to the target process, so that the Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt; can perform I/O operations into the target process&#39; memory. Backed by the m_targetProcess field. ">TargetProcess</a> object isn't attached, this method returns <div class="fragment"><div class="line"><span class="keyword">false</span></div></div><!-- fragment -->. Else, this method returns a flag specifying if the code cave has been injected. This method returns false for all code caves without a definition, as undefined injection artifacts are never injected. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">NullReferenceException</td><td>Thrown when the <a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#a4ac3521ce1d4882d8ea0649d7829243f" title="The object used to attach to the target process, so that the Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt; can perform I/O operations into the target process&#39; memory. Backed by the m_targetProcess field. ">TargetProcess</a> hasn't been set for this <a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#a419370074a281efc1ead6d988da539eb" title="Constructor. The constructor of the Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt; class chec...">Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt;</a>.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acdd8dadeaac352e221b9ea5e5a884434"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdd8dadeaac352e221b9ea5e5a884434">&#9670;&nbsp;</a></span>IsVariableInjected()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html">RAMvader.CodeInjection.Injector</a>&lt; TMemoryAlterationSetID, TCodeCave, TVariable &gt;.IsVariableInjected </td>
          <td>(</td>
          <td class="paramtype">TVariable&#160;</td>
          <td class="paramname"><em>varID</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verifies if a given variable has been injected by the <a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#a419370074a281efc1ead6d988da539eb" title="Constructor. The constructor of the Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt; class chec...">Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt;</a> on the target process' memory space. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">varID</td><td>The variable whose injection needs to be verified.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If the <a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#a419370074a281efc1ead6d988da539eb" title="Constructor. The constructor of the Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt; class chec...">Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt;</a> hasn't performed the injection procedure yet, or if its associated <a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#a4ac3521ce1d4882d8ea0649d7829243f" title="The object used to attach to the target process, so that the Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt; can perform I/O operations into the target process&#39; memory. Backed by the m_targetProcess field. ">TargetProcess</a> object isn't attached, this method returns <div class="fragment"><div class="line"><span class="keyword">false</span></div></div><!-- fragment -->. Else, this method returns a flag specifying if the variable has been injected. This method returns false for all variables without a definition, as undefined injection artifacts are never injected. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">NullReferenceException</td><td>Thrown when the <a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#a4ac3521ce1d4882d8ea0649d7829243f" title="The object used to attach to the target process, so that the Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt; can perform I/O operations into the target process&#39; memory. Backed by the m_targetProcess field. ">TargetProcess</a> hasn't been set for this <a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#a419370074a281efc1ead6d988da539eb" title="Constructor. The constructor of the Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt; class chec...">Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt;</a>.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abf1e6af657393826a1cfeb99a4b94897"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf1e6af657393826a1cfeb99a4b94897">&#9670;&nbsp;</a></span>NewCodeCave()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_code_cave_builder.html">CodeCaveBuilder</a>&lt;TMemoryAlterationSetID,TCodeCave,TVariable&gt; <a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html">RAMvader.CodeInjection.Injector</a>&lt; TMemoryAlterationSetID, TCodeCave, TVariable &gt;.NewCodeCave </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Instantiates a CodeCaveBuilder&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt; to allow for the creation of a new code cave that can be used with this <a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#a419370074a281efc1ead6d988da539eb" title="Constructor. The constructor of the Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt; class chec...">Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt;</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns a builder that can be used to create a new code cave for this <a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#a419370074a281efc1ead6d988da539eb" title="Constructor. The constructor of the Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt; class chec...">Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt;</a>.</dd></dl>

</div>
</div>
<a id="ada27879a75035a2c4517f397c2591d8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada27879a75035a2c4517f397c2591d8c">&#9670;&nbsp;</a></span>ReadVariableValue&lt; T &gt;()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html">RAMvader.CodeInjection.Injector</a>&lt; TMemoryAlterationSetID, TCodeCave, TVariable &gt;.ReadVariableValue&lt; T &gt; </td>
          <td>(</td>
          <td class="paramtype">TVariable&#160;</td>
          <td class="paramname"><em>variableID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ref T&#160;</td>
          <td class="paramname"><em>outDestiny</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the current value of a given variable from the target process' memory. This method is safe, as it checks the given variable's metadata against the given output variable's type to see if it matches the injected variable's type before reading the output value. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the variable to be read, which must match the type of the injected variable.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">variableID</td><td>The identifier of the variable whose value is to be read from the target process' memory space.</td></tr>
    <tr><td class="paramname">outDestiny</td><td>The result of the reading will be stored in this variable. The referenced variable's data must be of the same type as declared for the variable defined in parameter <div class="fragment"><div class="line">variableID</div></div><!-- fragment -->. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the result of the read operation performed by a call to <a class="el" href="class_r_a_mvader_1_1_target.html#a97d5017388700d23446f2f23fa232acc" title="Reads a value from the target process&#39; memory.">Target.ReadFromTarget&lt;T&gt;(MemoryAddress, ref T)</a>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">NullReferenceException</td><td>Thrown when the <a class="el" href="class_r_a_mvader_1_1_target.html" title="RAMvader library&#39;s core class. Instances of this class are able to &quot;attach&quot; to processes and execute ...">Target</a> associated with the <a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#a419370074a281efc1ead6d988da539eb" title="Constructor. The constructor of the Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt; class chec...">Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt;</a> hasn't been set. A <a class="el" href="class_r_a_mvader_1_1_target.html" title="RAMvader library&#39;s core class. Instances of this class are able to &quot;attach&quot; to processes and execute ...">Target</a> instance can be associated to an <a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#a419370074a281efc1ead6d988da539eb" title="Constructor. The constructor of the Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt; class chec...">Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt;</a> by calling the method <a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#ad901aa5384b7e4f5c87362003c432e6f" title="Initializes or modifies the reference to the object used by the Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt; to perform write operations to the target process&#39; memory. The Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt; also uses this object to know the endianness and pointer size of the target process. ">Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt;.SetTargetProcess(Target)</a>. </td></tr>
    <tr><td class="paramname"><a class="el" href="class_r_a_mvader_1_1_instance_not_attached_exception.html" title="Exception thrown when a method that requires the Target instance to be attached is called...">InstanceNotAttachedException</a></td><td>Thrown when the <a class="el" href="class_r_a_mvader_1_1_target.html" title="RAMvader library&#39;s core class. Instances of this class are able to &quot;attach&quot; to processes and execute ...">Target</a> instance has not been attached to a target process before the method is called. </td></tr>
    <tr><td class="paramname"><a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injection_artifact_not_found_exception.html" title="Exception thrown whenever an operation fails to find an injection artifact (which includes injection ...">InjectionArtifactNotFoundException</a></td><td>Thrown when the variable has not been injected in the target process' memory space. This happens when the variable has no definition (<a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_variable_definition.html" title="Keeps the metadata related to an injection variable.">VariableDefinition</a>) registered for it with the <a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#a419370074a281efc1ead6d988da539eb" title="Constructor. The constructor of the Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt; class chec...">Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt;</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a968f4ba0e6c9f717907c81e439a51675"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a968f4ba0e6c9f717907c81e439a51675">&#9670;&nbsp;</a></span>RemoveMemoryAlteration()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html">RAMvader.CodeInjection.Injector</a>&lt; TMemoryAlterationSetID, TCodeCave, TVariable &gt;.RemoveMemoryAlteration </td>
          <td>(</td>
          <td class="paramtype">TMemoryAlterationSetID&#160;</td>
          <td class="paramname"><em>memoryAlterationSetID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_memory_alteration_base.html">MemoryAlterationBase</a>&#160;</td>
          <td class="paramname"><em>memoryAlteration</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes a memory alteration from the set of alterations related to a given identifier. Memory alteration sets are kept in as list, and this method removes a memory alteration from this list. The elements of a set of memory alterations are enabled/disabled in the order they get added to the list. You can then call <a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#a424976a64ff18332548d98c4fc603f74" title="Activates or deactivates all the memory alterations registered for a given memory alterations set...">SetMemoryAlterationsActive(TMemoryAlterationSetID, bool)</a> to enable or disable the whole set of alterations related to an identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">memoryAlterationSetID</td><td>The identifier that identifies the set of alterations that can be enabled/disabled all at once.</td></tr>
    <tr><td class="paramname">memoryAlteration</td><td>The memory alteration to be removed from the given set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a flag specifying if the alteration has been removed from the set.</dd></dl>

</div>
</div>
<a id="ae718ee1ec135b8b74709770d87829bef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae718ee1ec135b8b74709770d87829bef">&#9670;&nbsp;</a></span>ResetAllocatedMemoryData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html">RAMvader.CodeInjection.Injector</a>&lt; TMemoryAlterationSetID, TCodeCave, TVariable &gt;.ResetAllocatedMemoryData </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resets the internal data of the <a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#a419370074a281efc1ead6d988da539eb" title="Constructor. The constructor of the Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt; class chec...">Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt;</a> regarding the memory region where it has injected its data. This method should be called whenever the target process is terminated or whenever the <a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#a419370074a281efc1ead6d988da539eb" title="Constructor. The constructor of the Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt; class chec...">Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt;</a> object needs to deallocate the memory it has allocated on the target process. </p>

</div>
</div>
<a id="a8ae5cd06168e3dc0130d69115722a0eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ae5cd06168e3dc0130d69115722a0eb">&#9670;&nbsp;</a></span>SetAllMemoryAlterationsActive()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html">RAMvader.CodeInjection.Injector</a>&lt; TMemoryAlterationSetID, TCodeCave, TVariable &gt;.SetAllMemoryAlterationsActive </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bActivate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Activates or deactivates all the memory alterations registered with the <a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#a419370074a281efc1ead6d988da539eb" title="Constructor. The constructor of the Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt; class chec...">Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt;</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bActivate</td><td>A flag specifying if the alterations should be activated or deactivated.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a flag specifying if all alterations have been activated. If any of the memory alterations in a set fail to be activated/deactivated, the returned value is false. </dd></dl>

</div>
</div>
<a id="af70129163be21cd5b4efddab923a9740"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af70129163be21cd5b4efddab923a9740">&#9670;&nbsp;</a></span>SetCodeCaveDefinition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html">RAMvader.CodeInjection.Injector</a>&lt; TMemoryAlterationSetID, TCodeCave, TVariable &gt;.SetCodeCaveDefinition </td>
          <td>(</td>
          <td class="paramtype">TCodeCave&#160;</td>
          <td class="paramname"><em>caveId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_code_cave_definition.html">CodeCaveDefinition</a>&lt; TMemoryAlterationSetID, TCodeCave, TVariable &gt;&#160;</td>
          <td class="paramname"><em>definition</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Updates the definition of a given code cave.</p>
<p>Currently, the definitions of code caves and injection variables can only be updated when the <a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#a419370074a281efc1ead6d988da539eb" title="Constructor. The constructor of the Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt; class chec...">Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt;</a> is in the "not injected" state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">caveId</td><td>The identifier of the code cave whose definition is to be updated.</td></tr>
    <tr><td class="paramname">definition</td><td>An object representing the new definition of the given code cave.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_instance_already_injected_exception.html" title="Exception thrown when a method that requires the Injector&lt;TMemoryAlterationSetID, TCodeCave...">InstanceAlreadyInjectedException</a></td><td>Thrown when the <a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#a419370074a281efc1ead6d988da539eb" title="Constructor. The constructor of the Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt; class chec...">Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt;</a>'s instance is already in "injected" state (this method must be called before that state is entered). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3ed24d89ef5afd453fdf1bd473b7493c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ed24d89ef5afd453fdf1bd473b7493c">&#9670;&nbsp;</a></span>SetCodeCavesSeparationBytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html">RAMvader.CodeInjection.Injector</a>&lt; TMemoryAlterationSetID, TCodeCave, TVariable &gt;.SetCodeCavesSeparationBytes </td>
          <td>(</td>
          <td class="paramtype">params byte []&#160;</td>
          <td class="paramname"><em>byteSeq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Modifies the sequence of bytes used to separate two consecutive code caves.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">byteSeq</td><td>The new sequence of bytes to use as a separator. This can be an empty array, but should not be null.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a424976a64ff18332548d98c4fc603f74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a424976a64ff18332548d98c4fc603f74">&#9670;&nbsp;</a></span>SetMemoryAlterationsActive()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html">RAMvader.CodeInjection.Injector</a>&lt; TMemoryAlterationSetID, TCodeCave, TVariable &gt;.SetMemoryAlterationsActive </td>
          <td>(</td>
          <td class="paramtype">TMemoryAlterationSetID&#160;</td>
          <td class="paramname"><em>memoryAlterationSetID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bActivate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Activates or deactivates all the memory alterations registered for a given memory alterations set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">memoryAlterationSetID</td><td>The identifier that identifies the set of alterations that can be enabled/disabled all at once.</td></tr>
    <tr><td class="paramname">bActivate</td><td>A flag specifying if the alterations should be activated or deactivated.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a flag specifying if all alterations have been activated. If any of the memory alterations in a set fail to be activated/deactivated, the returned value is false. </dd></dl>

</div>
</div>
<a id="ad901aa5384b7e4f5c87362003c432e6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad901aa5384b7e4f5c87362003c432e6f">&#9670;&nbsp;</a></span>SetTargetProcess()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html">RAMvader.CodeInjection.Injector</a>&lt; TMemoryAlterationSetID, TCodeCave, TVariable &gt;.SetTargetProcess </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_r_a_mvader_1_1_target.html">Target</a>&#160;</td>
          <td class="paramname"><em>targetProc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes or modifies the reference to the object used by the <a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#a419370074a281efc1ead6d988da539eb" title="Constructor. The constructor of the Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt; class chec...">Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt;</a> to perform write operations to the target process' memory. The <a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#a419370074a281efc1ead6d988da539eb" title="Constructor. The constructor of the Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt; class chec...">Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt;</a> also uses this object to know the endianness and pointer size of the target process. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">targetProc</td><td>The object used for performing memory I/O operations on the target process.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#a8f3a5f9dbe3bf46fa64c3d856d553b78" title="Retrieves the current reference to the object used by the Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt; to perform write operations to the target process&#39; memory. The Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt; also uses this object to know the endianness and pointer size of the target process. ">GetTargetProcess</a></dd></dl>

</div>
</div>
<a id="a5ef8e379cc7b256b418617e03ba2b591"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ef8e379cc7b256b418617e03ba2b591">&#9670;&nbsp;</a></span>SetVariableDefinition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html">RAMvader.CodeInjection.Injector</a>&lt; TMemoryAlterationSetID, TCodeCave, TVariable &gt;.SetVariableDefinition </td>
          <td>(</td>
          <td class="paramtype">TVariable&#160;</td>
          <td class="paramname"><em>varId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_variable_definition.html">VariableDefinition</a>&#160;</td>
          <td class="paramname"><em>definition</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>Updates the definition of a given injection variable.</p>
<p>Currently, the definitions of code caves and injection variables can only be updated when the <a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#a419370074a281efc1ead6d988da539eb" title="Constructor. The constructor of the Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt; class chec...">Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt;</a> is in the "not injected" state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">varId</td><td>The identifier of the injection variable whose definition is to be updated.</td></tr>
    <tr><td class="paramname">definition</td><td>An object representing the new definition of the given injection variable.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_instance_already_injected_exception.html" title="Exception thrown when a method that requires the Injector&lt;TMemoryAlterationSetID, TCodeCave...">InstanceAlreadyInjectedException</a></td><td>Thrown when the <a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#a419370074a281efc1ead6d988da539eb" title="Constructor. The constructor of the Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt; class chec...">Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt;</a>'s instance is already in "injected" state (this method must be called before that state is entered). </td></tr>
    <tr><td class="paramname"><a class="el" href="class_r_a_mvader_1_1_unsupported_data_type_exception.html" title="An exception which is thrown when the user tries to perform a read or write operation using a data ty...">UnsupportedDataTypeException</a></td><td>Throw when the type of the </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a25f2c1decddf86048b6ee93e44a2f122"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25f2c1decddf86048b6ee93e44a2f122">&#9670;&nbsp;</a></span>SetVariablesSectionSeparationBytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html">RAMvader.CodeInjection.Injector</a>&lt; TMemoryAlterationSetID, TCodeCave, TVariable &gt;.SetVariablesSectionSeparationBytes </td>
          <td>(</td>
          <td class="paramtype">params byte []&#160;</td>
          <td class="paramname"><em>byteSeq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Modifies the sequence of bytes used to separate the injected code caves section from the injected variables section.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">byteSeq</td><td>The new sequence of bytes to use as a separator. This can be an empty array, but should not be null.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab53889e9bdbcbdd0ea99669840f528a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab53889e9bdbcbdd0ea99669840f528a7">&#9670;&nbsp;</a></span>WriteVariableValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html">RAMvader.CodeInjection.Injector</a>&lt; TMemoryAlterationSetID, TCodeCave, TVariable &gt;.WriteVariableValue </td>
          <td>(</td>
          <td class="paramtype">TVariable&#160;</td>
          <td class="paramname"><em>variableID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">object&#160;</td>
          <td class="paramname"><em>newValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates the value of a given variable into the target process' memory. This method is safe, as it checks the given variable's metadata against the given value's type to see if it matches the variable's type before updating the variable's value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">variableID</td><td>The identifier of the injected variable whose value is to be updated.</td></tr>
    <tr><td class="paramname">newValue</td><td>The new value for the variable.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the result of the write operation performed by a call to Target.WriteToTarget(MemoryAddress, object).</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">NullReferenceException</td><td>Thrown when the <a class="el" href="class_r_a_mvader_1_1_target.html" title="RAMvader library&#39;s core class. Instances of this class are able to &quot;attach&quot; to processes and execute ...">Target</a> associated with the <a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#a419370074a281efc1ead6d988da539eb" title="Constructor. The constructor of the Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt; class chec...">Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt;</a> hasn't been set. A <a class="el" href="class_r_a_mvader_1_1_target.html" title="RAMvader library&#39;s core class. Instances of this class are able to &quot;attach&quot; to processes and execute ...">Target</a> instance can be associated to an <a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#a419370074a281efc1ead6d988da539eb" title="Constructor. The constructor of the Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt; class chec...">Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt;</a> by calling the method <a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#ad901aa5384b7e4f5c87362003c432e6f" title="Initializes or modifies the reference to the object used by the Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt; to perform write operations to the target process&#39; memory. The Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt; also uses this object to know the endianness and pointer size of the target process. ">Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt;.SetTargetProcess(Target)</a>. </td></tr>
    <tr><td class="paramname"><a class="el" href="class_r_a_mvader_1_1_instance_not_attached_exception.html" title="Exception thrown when a method that requires the Target instance to be attached is called...">InstanceNotAttachedException</a></td><td>Thrown when the <a class="el" href="class_r_a_mvader_1_1_target.html" title="RAMvader library&#39;s core class. Instances of this class are able to &quot;attach&quot; to processes and execute ...">Target</a> instance has not been attached to a target process before the method is called. </td></tr>
    <tr><td class="paramname"><a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_unmatched_data_type_exception.html" title="Exception thrown when trying to perform an operation involving injection variables, and the data type used is different from the data type of the injection variable. Read/write operations on injection variables must ALWAYS match the exact type declared for the injection variable. ">UnmatchedDataTypeException</a></td><td>Thrown when "newValue" does not match the injection variable's type.</td></tr>
    <tr><td class="paramname"><a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injection_artifact_not_found_exception.html" title="Exception thrown whenever an operation fails to find an injection artifact (which includes injection ...">InjectionArtifactNotFoundException</a></td><td>Thrown when the variable has not been injected in the target process' memory space. This happens when the variable has no definition (<a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_variable_definition.html" title="Keeps the metadata related to an injection variable.">VariableDefinition</a>) registered for it with the <a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#a419370074a281efc1ead6d988da539eb" title="Constructor. The constructor of the Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt; class chec...">Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt;</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9d6e715c35dbe9d30390974ca3fc6666"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d6e715c35dbe9d30390974ca3fc6666">&#9670;&nbsp;</a></span>WriteX86BranchInstruction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html">RAMvader.CodeInjection.Injector</a>&lt; TMemoryAlterationSetID, TCodeCave, TVariable &gt;.WriteX86BranchInstruction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_r_a_mvader.html#a9e2b14ce7eb13c552fd5175e8b3d7d44">EX86BranchInstructionType</a>&#160;</td>
          <td class="paramname"><em>instructionType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_r_a_mvader_1_1_memory_address.html">MemoryAddress</a>&#160;</td>
          <td class="paramname"><em>branchPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_r_a_mvader_1_1_memory_address.html">MemoryAddress</a>&#160;</td>
          <td class="paramname"><em>targetAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>instructionSize</em> = <code>X86Constants.INSTRUCTION_SIZE_ANY</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a x86 branch instruction at a specific point of the target process' memory space to enable the process' execution flow to be branched to another specific address. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instructionType</td><td>The specific type of branch instruction to be generated.</td></tr>
    <tr><td class="paramname">branchPoint</td><td>The address of the target process' memory space where the branch instruction will be written.</td></tr>
    <tr><td class="paramname">targetAddress</td><td>The address to where the target process' execution should be diverted.</td></tr>
    <tr><td class="paramname">instructionSize</td><td>The size of the instruction that is going to be replaced by the branch instruction. This is used to fill the remaining bytes of the instruction with NOP opcodes, so that when the execution flows back from the branch instruction (if it ever does), nothing unexpected happens.</td></tr>
  </table>
  </dd>
</dl>
<p>If the size does not matter, X86Constants.INSTRUCTION_SIZE_ANY can be used. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns a flag indicating the success of the operation.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">NullReferenceException</td><td>Thrown when the <a class="el" href="class_r_a_mvader_1_1_target.html" title="RAMvader library&#39;s core class. Instances of this class are able to &quot;attach&quot; to processes and execute ...">Target</a> associated with the <a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#a419370074a281efc1ead6d988da539eb" title="Constructor. The constructor of the Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt; class chec...">Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt;</a> hasn't been set. A <a class="el" href="class_r_a_mvader_1_1_target.html" title="RAMvader library&#39;s core class. Instances of this class are able to &quot;attach&quot; to processes and execute ...">Target</a> instance can be associated to an <a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#a419370074a281efc1ead6d988da539eb" title="Constructor. The constructor of the Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt; class chec...">Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt;</a> by calling the method <a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#ad901aa5384b7e4f5c87362003c432e6f" title="Initializes or modifies the reference to the object used by the Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt; to perform write operations to the target process&#39; memory. The Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt; also uses this object to know the endianness and pointer size of the target process. ">Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt;.SetTargetProcess(Target)</a>. </td></tr>
    <tr><td class="paramname"><a class="el" href="class_r_a_mvader_1_1_instance_not_attached_exception.html" title="Exception thrown when a method that requires the Target instance to be attached is called...">InstanceNotAttachedException</a></td><td>Thrown when the <a class="el" href="class_r_a_mvader_1_1_target.html" title="RAMvader library&#39;s core class. Instances of this class are able to &quot;attach&quot; to processes and execute ...">Target</a> instance has not been attached to a target process before the method is called. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Property Documentation</h2>
<a id="ae7d09d9fac03e14b00aa5defd20c843f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7d09d9fac03e14b00aa5defd20c843f">&#9670;&nbsp;</a></span>BaseInjectionAddress</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">IntPtr <a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html">RAMvader.CodeInjection.Injector</a>&lt; TMemoryAlterationSetID, TCodeCave, TVariable &gt;.BaseInjectionAddress</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Keeps the base address of the memory which was allocated for the target process. Backed by the m_baseInjectionAddress field. </p>

</div>
</div>
<a id="a3b497abbdbc0e3567606c798a039edfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b497abbdbc0e3567606c798a039edfd">&#9670;&nbsp;</a></span>CodeCaveOffset</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">NestedPropertyIndexerCodeCaveOffset <a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html">RAMvader.CodeInjection.Injector</a>&lt; TMemoryAlterationSetID, TCodeCave, TVariable &gt;.CodeCaveOffset</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indexer property used to access the code cave offsets, usually for WPF Binding purposes. Calls <a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#afbe434daacbcc5f9f2199c55310bd3fc" title="Retrieves the offset of a given code cave, relative to the base injection address into the target pro...">Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt;.GetCodeCaveOffset(TCodeCave)</a> internally. Backed by the m_codeCaveOffset field. </p>

</div>
</div>
<a id="a275c4239fa61eb51341ba4484a43ce50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a275c4239fa61eb51341ba4484a43ce50">&#9670;&nbsp;</a></span>InjectedCodeCaveAddress</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">NestedPropertyIndexerInjectedCodeCaveAddress <a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html">RAMvader.CodeInjection.Injector</a>&lt; TMemoryAlterationSetID, TCodeCave, TVariable &gt;.InjectedCodeCaveAddress</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indexer property used to access the address where a code cave has been injected, usually for WPF Binding purposes. Calls <a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#a9467a81ecc9e38bc95abe2dd42ebd767" title="Retrieves the address of an injected code cave. This method should only be called after a base inject...">Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt;.GetInjectedCodeCaveAddress(TCodeCave)</a> internally. Backed by the m_injectedCodeCaveAddress field. </p>

</div>
</div>
<a id="ab816b37f7a2bddc066a7934c05639138"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab816b37f7a2bddc066a7934c05639138">&#9670;&nbsp;</a></span>InjectedVariableAddress</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">NestedPropertyIndexerInjectedVariableAddress <a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html">RAMvader.CodeInjection.Injector</a>&lt; TMemoryAlterationSetID, TCodeCave, TVariable &gt;.InjectedVariableAddress</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indexer property used to access the address where a variable has been injected, usually for WPF Binding purposes. Calls <a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#a0de69746ab2fe19093d38aacd01bdada" title="Retrieves the address of an injected variable. This method should only be called after a base injecti...">Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt;.GetInjectedVariableAddress(TVariable)</a> internally. Backed by the m_injectedVariableAddress field. </p>

</div>
</div>
<a id="aed5e8725ccedc94fc5a35970ccbfc988"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed5e8725ccedc94fc5a35970ccbfc988">&#9670;&nbsp;</a></span>IsInjected</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html">RAMvader.CodeInjection.Injector</a>&lt; TMemoryAlterationSetID, TCodeCave, TVariable &gt;.IsInjected</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A flag that is set to true whenever the <a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#a96b48ff9f2c0bb415c94810299982159" title="Allocates memory into the target process&#39; memory space and injects the code caves and variables into ...">Inject()</a> (or <a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#a75bba917eadc2711528f672d7cd536bf">Inject(MemoryAddress)</a>) method is called and succeeds, and set to false whenever the<a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#ae718ee1ec135b8b74709770d87829bef" title="Resets the internal data of the Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt; regarding the ...">ResetAllocatedMemoryData</a> gets called. </p>

</div>
</div>
<a id="a2c44b0feaf095b0e55d80f91ce855ab8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c44b0feaf095b0e55d80f91ce855ab8">&#9670;&nbsp;</a></span>RequiredBytesCount</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html">RAMvader.CodeInjection.Injector</a>&lt; TMemoryAlterationSetID, TCodeCave, TVariable &gt;.RequiredBytesCount</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The total number of required bytes to inject the code caves and variables into the target process' memory space, as calculated by a call to the method <a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#afca31c63dacc7873439b66908ef84714" title="Calculates the total number of required bytes to inject the code caves and variables into the target ...">CalculateRequiredBytesCount</a>. </p>

</div>
</div>
<a id="a4ac3521ce1d4882d8ea0649d7829243f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ac3521ce1d4882d8ea0649d7829243f">&#9670;&nbsp;</a></span>TargetProcess</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_r_a_mvader_1_1_target.html">Target</a> <a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html">RAMvader.CodeInjection.Injector</a>&lt; TMemoryAlterationSetID, TCodeCave, TVariable &gt;.TargetProcess</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The object used to attach to the target process, so that the <a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#a419370074a281efc1ead6d988da539eb" title="Constructor. The constructor of the Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt; class chec...">Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt;</a> can perform I/O operations into the target process' memory. Backed by the m_targetProcess field. </p>

</div>
</div>
<a id="ad57b0685d0e4c07c44f1f064a968192d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad57b0685d0e4c07c44f1f064a968192d">&#9670;&nbsp;</a></span>VariableOffset</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">NestedPropertyIndexerVariableOffset <a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html">RAMvader.CodeInjection.Injector</a>&lt; TMemoryAlterationSetID, TCodeCave, TVariable &gt;.VariableOffset</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indexer property used to access variable offsets, usually for WPF Binding purposes. Calls <a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#a6ac14f4ef2ba785e139cf4f937b3b000" title="Retrieves the offset of a given variable, relative to the base injection address into the target proc...">Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt;.GetVariableOffset(TVariable)</a> internally. Backed by the m_variableOffset field. </p>

</div>
</div>
<a id="a652d205141e1d13f17c75b3bef8d4604"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a652d205141e1d13f17c75b3bef8d4604">&#9670;&nbsp;</a></span>VariableSize</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">NestedPropertyIndexerVariableSize <a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html">RAMvader.CodeInjection.Injector</a>&lt; TMemoryAlterationSetID, TCodeCave, TVariable &gt;.VariableSize</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indexer property used to retrieve the size of a variable, usually for WPF Binding purposes. Calls <a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html#a851b55538b48bb2292b2a4553fffd313" title="Retrieves the size of a given injection variable.">Injector&lt;TMemoryAlterationSetID, TCodeCave, TVariable&gt;.GetVariableSize(TVariable)</a> internally. Backed by the m_variableSize field. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_r_a_mvader.html">RAMvader</a></li><li class="navelem"><a class="el" href="namespace_r_a_mvader_1_1_code_injection.html">CodeInjection</a></li><li class="navelem"><a class="el" href="class_r_a_mvader_1_1_code_injection_1_1_injector.html">Injector</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.14 </li>
  </ul>
</div>
</body>
</html>
