using System;
using System.Collections.Generic;

namespace RAMvader.CodeInjection
{
	/// <summary>
	///    <para>
	///       A class specialized in building <see cref="CodeCaveDefinition{TMemoryAlterationSetID, TCodeCave, TVariable}"/> objects.
	///       This class follows a fluid design pattern, allowing calls to its code cave construction-related methods to
	///       be cascaded, making code easier to read and maintain.
	///    </para>
	///    <para>
	///       Under the hoods, this class generates <see cref="CodeCaveArtifact{TMemoryAlterationSetID, TCodeCave, TVariable}"/> objects,
	///       which are kept in a list that can be used to generate the code cave definition.
	///    </para>
	///    <para>
	///    </para>
	/// </summary>
	public class CodeCaveBuilder<TMemoryAlterationSetID, TCodeCave, TVariable>
	{
		#region PRIVATE FIELDS
		/// <summary>
		///    A reference to the <see cref="Injector{TMemoryAlterationSetID, TCodeCave, TVariable}"/> object to which
		///    the <see cref="CodeCaveDefinition{TMemoryAlterationSetID, TCodeCave, TVariable}"/> objects will be created.
		/// </summary>
		private Injector<TMemoryAlterationSetID, TCodeCave, TVariable> m_injector;
		/// <summary>The list of artifacts that have currently been generated by the <see cref="CodeCaveBuilder{TMemoryAlterationSetID, TCodeCave, TVariable}"/>.</summary>
		private List<CodeCaveArtifact<TMemoryAlterationSetID, TCodeCave, TVariable>> m_artifacts = new List<CodeCaveArtifact<TMemoryAlterationSetID, TCodeCave, TVariable>>();
		#endregion





		#region PUBLIC METHODS
		/// <summary>Constructor.</summary>
		/// <param name="injector">
		///    A reference to the <see cref="Injector{TMemoryAlterationSetID, TCodeCave, TVariable}"/> object to which
		///    the <see cref="CodeCaveDefinition{TMemoryAlterationSetID, TCodeCave, TVariable}"/> objects will be created.
		/// </param>
		public CodeCaveBuilder( Injector<TMemoryAlterationSetID,TCodeCave,TVariable> injector )
		{
			m_injector = injector;
		}


		/// <summary>
		///    Called as the last step for building a <see cref="CodeCaveDefinition{TMemoryAlterationSetID, TCodeCave, TVariable}"/>,
		///    returning the produced definition.
		/// </summary>
		/// <returns>Returns the created <see cref="CodeCaveDefinition{TMemoryAlterationSetID, TCodeCave, TVariable}"/> instance.</returns>
		public CodeCaveDefinition<TMemoryAlterationSetID, TCodeCave, TVariable> Build()
		{
			CodeCaveDefinition<TMemoryAlterationSetID, TCodeCave, TVariable> result = new CodeCaveDefinition<TMemoryAlterationSetID, TCodeCave, TVariable>();

			CodeCaveArtifact<TMemoryAlterationSetID, TCodeCave, TVariable> [] artifactsList = this.m_artifacts.ToArray();
			result.SetArtifactsArray( artifactsList );

			return result;
		}


		/// <summary>
		///    Adds the bytes that represent the address of an injected code cave to the code cave being built.
		///    This effectivelly adds a <see cref="CodeCaveArtifactVariableAddress{TMemoryAlterationSetID, TCodeCave, TVariable}"/>
		///    artifact to the list of generated artifacts.
		/// </summary>
		/// <param name="varId">The identifier of the variable whose address will be added.</param>
		/// <returns>Returns a reference to the object used to call the method.</returns>
		public CodeCaveBuilder<TMemoryAlterationSetID, TCodeCave, TVariable> VarAddr( TVariable varId )
		{
			m_artifacts.Add( new CodeCaveArtifactVariableAddress<TMemoryAlterationSetID, TCodeCave, TVariable>( varId ) );
			return this;
		}


		/// <summary>
		///    Adds the bytes that represent the address of an injected variable to the code cave being built.
		///    This effectivelly adds a <see cref="CodeCaveArtifactCodeCaveAddress{TMemoryAlterationSetID, TCodeCave, TVariable}"/>
		///    artifact to the list of generated artifacts.
		/// </summary>
		/// <param name="caveId">The identifier of the code cave whose address will be added.</param>
		/// <returns>Returns a reference to the object used to call the method.</returns>
		public CodeCaveBuilder<TMemoryAlterationSetID, TCodeCave, TVariable> CaveAddr( TCodeCave caveId )
		{
			m_artifacts.Add( new CodeCaveArtifactCodeCaveAddress<TMemoryAlterationSetID, TCodeCave, TVariable>( caveId ) );
			return this;
		}


		/// <summary>
		///    Adds the given sequence of signed bytes (<see cref="SByte"/>) to the code cave being built.
		///    This effectivelly adds a <see cref="CodeCaveArtifactSignedBytesSequence{TMemoryAlterationSetID, TCodeCave, TVariable}"/>
		///    artifact to the list of generated artifacts.
		/// </summary>
		/// <param name="bytes">The sequence of (signed) bytes which will be added.</param>
		/// <returns>Returns a reference to the object used to call the method.</returns>
		public CodeCaveBuilder<TMemoryAlterationSetID, TCodeCave, TVariable> SBytes( params sbyte[] bytes )
		{
			m_artifacts.Add( new CodeCaveArtifactSignedBytesSequence<TMemoryAlterationSetID, TCodeCave, TVariable>( bytes ) );
			return this;
		}


		/// <summary>
		///    Adds the given sequence of unsigned bytes (<see cref="Byte"/>) to the code cave being built.
		///    This effectivelly adds a <see cref="CodeCaveArtifactUnsignedBytesSequence{TMemoryAlterationSetID, TCodeCave, TVariable}"/>
		///    artifact to the list of generated artifacts.
		/// </summary>
		/// <param name="bytes">The sequence of (unsigned) bytes which will be added.</param>
		/// <returns>Returns a reference to the object used to call the method.</returns>
		public CodeCaveBuilder<TMemoryAlterationSetID, TCodeCave, TVariable> Bytes( params byte[] bytes )
		{
			m_artifacts.Add( new CodeCaveArtifactUnsignedBytesSequence<TMemoryAlterationSetID, TCodeCave, TVariable>( bytes ) );
			return this;
		}


		/// <summary>
		///    Adds the bytes corresponding to a CALL instruction to the code cave being built.
		///    This effectivelly adds a <see cref="CodeCaveArtifactX86Call{TMemoryAlterationSetID, TCodeCave, TVariable}"/>
		///    artifact to the list of generated artifacts.
		/// </summary>
		/// <param name="targetAddress">The address to be CALLed.</param>
		/// <returns>Returns a reference to the object used to call the method.</returns>
		public CodeCaveBuilder<TMemoryAlterationSetID, TCodeCave, TVariable> X86Call( MemoryAddress targetAddress )
		{
			m_artifacts.Add( new CodeCaveArtifactX86Call<TMemoryAlterationSetID, TCodeCave, TVariable>( targetAddress ) );
			return this;
		}


		/// <summary>
		///    Adds the bytes corresponding to a NEAR JUMP instruction to the code cave being built.
		///    This effectivelly adds a <see cref="CodeCaveArtifactX86NearJump{TMemoryAlterationSetID, TCodeCave, TVariable}"/>
		///    artifact to the list of generated artifacts.
		/// </summary>
		/// <param name="jumpInstructionType">The specific type of jump instruction to be generated.</param>
		/// <param name="targetAddress">The address to which the instruction will jump.</param>
		/// <returns>Returns a reference to the object used to call the method.</returns>
		public CodeCaveBuilder<TMemoryAlterationSetID, TCodeCave, TVariable> X86NearJump( EJumpInstructionType jumpInstructionType, MemoryAddress targetAddress )
		{
			m_artifacts.Add( new CodeCaveArtifactX86NearJump<TMemoryAlterationSetID, TCodeCave, TVariable>( jumpInstructionType, targetAddress ) );
			return this;
		}


		/// <summary>
		///    Adds the bytes corresponding to a FAR JUMP instruction to the code cave being built.
		///    This effectivelly adds a <see cref="CodeCaveArtifactX86FarJump{TMemoryAlterationSetID, TCodeCave, TVariable}"/>
		///    artifact to the list of generated artifacts.
		/// </summary>
		/// <param name="jumpInstructionType">The specific type of jump instruction to be generated.</param>
		/// <param name="targetAddress">The address to which the instruction will jump.</param>
		/// <returns>Returns a reference to the object used to call the method.</returns>
		public CodeCaveBuilder<TMemoryAlterationSetID, TCodeCave, TVariable> X86FarJump( EJumpInstructionType jumpInstructionType, MemoryAddress targetAddress )
		{
			m_artifacts.Add( new CodeCaveArtifactX86FarJump<TMemoryAlterationSetID, TCodeCave, TVariable>( jumpInstructionType, targetAddress ) );
			return this;
		}
		#endregion
	}
}
